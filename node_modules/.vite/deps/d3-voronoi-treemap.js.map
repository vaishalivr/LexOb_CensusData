{
  "version": 3,
  "sources": ["../../d3-voronoi-map/node_modules/d3-polygon/src/area.js", "../../d3-voronoi-map/node_modules/d3-polygon/src/centroid.js", "../../d3-voronoi-map/node_modules/d3-polygon/src/contains.js", "../../d3-voronoi-map/node_modules/d3-timer/src/timer.js", "../../d3-voronoi-map/node_modules/d3-dispatch/src/dispatch.js", "../../d3-weighted-voronoi/node_modules/d3-array/src/ascending.js", "../../d3-weighted-voronoi/node_modules/d3-array/src/bisector.js", "../../d3-weighted-voronoi/node_modules/d3-array/src/number.js", "../../d3-weighted-voronoi/node_modules/d3-array/src/bisect.js", "../../d3-weighted-voronoi/node_modules/d3-array/src/extent.js", "../../d3-weighted-voronoi/node_modules/d3-array/src/array.js", "../../d3-weighted-voronoi/node_modules/d3-array/src/ticks.js", "../../d3-weighted-voronoi/node_modules/d3-array/src/shuffle.js", "../../d3-weighted-voronoi/node_modules/d3-polygon/src/cross.js", "../../d3-weighted-voronoi/node_modules/d3-polygon/src/hull.js", "../../d3-weighted-voronoi/node_modules/d3-polygon/src/length.js", "../../d3-weighted-voronoi/src/utils.js", "../../d3-weighted-voronoi/src/conflictList.js", "../../d3-weighted-voronoi/src/vertex.js", "../../d3-weighted-voronoi/src/plane3D.js", "../../d3-weighted-voronoi/src/vector.js", "../../d3-weighted-voronoi/src/hEdge.js", "../../d3-weighted-voronoi/src/d3-weighted-voronoi-error.js", "../../d3-weighted-voronoi/src/face.js", "../../d3-weighted-voronoi/src/convexHull.js", "../../d3-weighted-voronoi/src/d3-polygon-clip.js", "../../d3-weighted-voronoi/src/powerDiagram.js", "../../d3-weighted-voronoi/src/d3-weighted-voronoi.js", "../../d3-voronoi-map/src/flickering-mitigation.js", "../../d3-voronoi-map/src/initial-position-policies/random.js", "../../d3-voronoi-map/src/initial-weight-policies/half-average-area.js", "../../d3-voronoi-map/src/d3-voronoi-map-error.js", "../../d3-voronoi-map/src/d3-voronoi-map.js", "../../d3-voronoi-treemap/src/d3-voronoi-treemap.js"],
  "sourcesContent": ["export default function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      a,\n      b = polygon[n - 1],\n      area = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n}\n", "export default function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      x = 0,\n      y = 0,\n      a,\n      b = polygon[n - 1],\n      c,\n      k = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    k += c = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * c;\n    y += (a[1] + b[1]) * c;\n  }\n\n  return k *= 3, [x / k, y / k];\n}\n", "export default function(polygon, point) {\n  var n = polygon.length,\n      p = polygon[n - 1],\n      x = point[0], y = point[1],\n      x0 = p[0], y0 = p[1],\n      x1, y1,\n      inside = false;\n\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x1 = p[0], y1 = p[1];\n    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;\n    x0 = x1, y0 = y1;\n  }\n\n  return inside;\n}\n", "var frame = 0, // is an animation frame pending?\n    timeout = 0, // is a timeout pending?\n    interval = 0, // are any timers active?\n    pokeDelay = 1000, // how frequently we check for clock skew\n    taskHead,\n    taskTail,\n    clockLast = 0,\n    clockNow = 0,\n    clockSkew = 0,\n    clock = typeof performance === \"object\" && performance.now ? performance : Date,\n    setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };\n\nexport function now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\n\nfunction clearNow() {\n  clockNow = 0;\n}\n\nexport function Timer() {\n  this._call =\n  this._time =\n  this._next = null;\n}\n\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time) {\n    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\n\nexport function timer(callback, delay, time) {\n  var t = new Timer;\n  t.restart(callback, delay, time);\n  return t;\n}\n\nexport function timerFlush() {\n  now(); // Get the current time, if not already set.\n  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n    t = t._next;\n  }\n  --frame;\n}\n\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\n\nfunction poke() {\n  var now = clock.now(), delay = now - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n}\n\nfunction nap() {\n  var t0, t1 = taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\n\nfunction sleep(time) {\n  if (frame) return; // Soonest alarm already set, or will be.\n  if (timeout) timeout = clearTimeout(timeout);\n  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.\n  if (delay > 24) {\n    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n", "var noop = {value: () => {}};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || (t in _) || /[\\s.]/.test(t)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {type: t, name: name};\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length;\n\n    // If no callback was specified, return the callback of the given type and name.\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n      return;\n    }\n\n    // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({name: name, value: callback});\n  return type;\n}\n\nexport default dispatch;\n", "export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n", "import ascending from \"./ascending.js\";\n\nexport default function(f) {\n  let delta = f;\n  let compare = f;\n\n  if (f.length === 1) {\n    delta = (d, x) => f(d) - x;\n    compare = ascendingComparator(f);\n  }\n\n  function left(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) < 0) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function right(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) > 0) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  function center(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction ascendingComparator(f) {\n  return (d, x) => ascending(f(d), x);\n}\n", "export default function(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n", "import ascending from \"./ascending.js\";\nimport bisector from \"./bisector.js\";\nimport number from \"./number.js\";\n\nconst ascendingBisect = bisector(ascending);\nexport const bisectRight = ascendingBisect.right;\nexport const bisectLeft = ascendingBisect.left;\nexport const bisectCenter = bisector(number).center;\nexport default bisectRight;\n", "export default function(values, valueof) {\n  let min;\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  }\n  return [min, max];\n}\n", "var array = Array.prototype;\n\nexport var slice = array.slice;\nexport var map = array.map;\n", "var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    let r0 = Math.round(start / step), r1 = Math.round(stop / step);\n    if (r0 * step < start) ++r0;\n    if (r1 * step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) * step;\n  } else {\n    step = -step;\n    let r0 = Math.round(start * step), r1 = Math.round(stop * step);\n    if (r0 / step < start) ++r0;\n    if (r1 / step > stop) --r1;\n    ticks = new Array(n = r1 - r0 + 1);\n    while (++i < n) ticks[i] = (r0 + i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n", "export default shuffler(Math.random);\n\nexport function shuffler(random) {\n  return function shuffle(array, i0 = 0, i1 = array.length) {\n    let m = i1 - (i0 = +i0);\n    while (m) {\n      const i = random() * m-- | 0, t = array[m + i0];\n      array[m + i0] = array[i + i0];\n      array[i + i0] = t;\n    }\n    return array;\n  };\n}\n", "// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n// negative if clockwise, and zero if the points are collinear.\nexport default function(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n}\n", "import cross from \"./cross.js\";\n\nfunction lexicographicOrder(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\n// Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\nfunction computeUpperHullIndexes(points) {\n  const n = points.length,\n      indexes = [0, 1];\n  let size = 2, i;\n\n  for (i = 2; i < n; ++i) {\n    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;\n    indexes[size++] = i;\n  }\n\n  return indexes.slice(0, size); // remove popped points\n}\n\nexport default function(points) {\n  if ((n = points.length) < 3) return null;\n\n  var i,\n      n,\n      sortedPoints = new Array(n),\n      flippedPoints = new Array(n);\n\n  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n      lowerIndexes = computeUpperHullIndexes(flippedPoints);\n\n  // Construct the hull polygon, removing possible duplicate endpoints.\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n      hull = [];\n\n  // Add upper hull in right-to-l order.\n  // Then add lower hull in left-to-right order.\n  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n\n  return hull;\n}\n", "export default function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      b = polygon[n - 1],\n      xa,\n      ya,\n      xb = b[0],\n      yb = b[1],\n      perimeter = 0;\n\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.hypot(xa, ya);\n  }\n\n  return perimeter;\n}\n", "export var epsilon = 1e-10;\n\nexport function epsilonesque(n) {\n  return n <= epsilon && n >= -epsilon;\n}\n\n// IN: vectors or vertices\n// OUT: dot product\nexport function dot(v0, v1) {\n  return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;\n}\n\n// IN: two vertex objects, v0 and v1\n// OUT: true if they are linearly dependent, false otherwise\n// from https://math.stackexchange.com/questions/1144357/how-can-i-prove-that-two-vectors-in-%E2%84%9D3-are-linearly-independent-iff-their-cro\nexport function linearDependent(v0, v1) {\n  return (\n    epsilonesque(v0.x * v1.y - v0.y * v1.x) &&\n    epsilonesque(v0.y * v1.z - v0.z * v1.y) &&\n    epsilonesque(v0.z * v1.x - v0.x * v1.z)\n  );\n}\n\n// IN: an array of 2D-points [x,y]\n// OUT: true if the set defines a convex polygon (non-intersecting, hole-free, non-concave)\n// from https://gist.github.com/annatomka/82715127b74473859054, adapted to [x,y] syntax (instead of {x: ..., y: ...}) and optimizations\nexport function polygonDirection(polygon) {\n  var sign, crossproduct, p0, p1, p2, v0, v1, i;\n\n  //begin: initialization\n  p0 = polygon[polygon.length - 2];\n  p1 = polygon[polygon.length - 1];\n  p2 = polygon[0];\n  v0 = vect(p0, p1);\n  v1 = vect(p1, p2);\n  crossproduct = calculateCrossproduct(v0, v1);\n  // console.log(`[[${p0}], [${p1}], [${p2}]] => (${v0}) x (${v1}) = ${crossproduct}`);\n  sign = Math.sign(crossproduct);\n  //end: initialization\n\n  p0 = p1; // p0 = polygon[polygon.length - 1];\n  p1 = p2; // p1 = polygon[0];\n  p2 = polygon[1];\n  v0 = v1;\n  v1 = vect(p1, p2);\n  crossproduct = calculateCrossproduct(v0, v1);\n  // console.log(`[[${p0}], [${p1}], [${p2}]] => (${v0}) x (${v1}) = ${crossproduct}`);\n  if (Math.sign(crossproduct) !== sign) {\n    return undefined;\n  } //different signs in cross products means concave polygon\n\n  //iterate on remaining 3 consecutive points\n  for (i = 2; i < polygon.length - 1; i++) {\n    p0 = p1;\n    p1 = p2;\n    p2 = polygon[i];\n    v0 = v1;\n    v1 = vect(p1, p2);\n    crossproduct = calculateCrossproduct(v0, v1);\n    // console.log(`[[${p0}], [${p1}], [${p2}]] => (${v0}) x (${v1}) = ${crossproduct}`);\n    if (Math.sign(crossproduct) !== sign) {\n      return undefined;\n    } //different signs in cross products means concave polygon\n  }\n\n  return sign;\n}\n\nfunction vect(from, to) {\n  return [to[0] - from[0], to[1] - from[1]];\n}\n\nfunction calculateCrossproduct(v0, v1) {\n  return v0[0] * v1[1] - v0[1] * v1[0];\n}\n", "// ConflictList and ConflictListNode\n\nexport function ConflictListNode (face, vert) {\n  this.face = face;\n  this.vert = vert;\n  this.nextf = null;\n  this.prevf = null;\n  this.nextv = null;\n  this.prevv = null;\n}\n\n// IN: boolean forFace\nexport function ConflictList (forFace) {\n  this.forFace = forFace;\n  this.head = null;\n}\n\n// IN: ConflictListNode cln\nConflictList.prototype.add = function(cln) {\n  if (this.head === null) {\n    this.head = cln;\n  } else {\n    if (this.forFace) {  // Is FaceList\n      this.head.prevv = cln;\n      cln.nextv = this.head;\n      this.head = cln;\n    } else {  // Is VertexList\n      this.head.prevf = cln;\n      cln.nextf = this.head;\n      this.head = cln;\n    }\n  }\n}\n\nConflictList.prototype.isEmpty = function() {\n  return this.head === null;\n}\n\n// Array of faces visible\nConflictList.prototype.fill = function(visible) {\n  if (this.forFace) {\n    return;\n  }\n  var curr = this.head;\n  do {\n    visible.push(curr.face);\n    curr.face.marked = true;\n    curr = curr.nextf;\n  } while (curr !== null);\n}\n\nConflictList.prototype.removeAll = function() {\n  if (this.forFace) {  // Remove all vertices from Face\n    var curr = this.head;\n    do {\n      if (curr.prevf === null) {  // Node is head\n        if (curr.nextf === null) {\n          curr.vert.conflicts.head = null;\n        } else {\n          curr.nextf.prevf = null;\n          curr.vert.conflicts.head = curr.nextf;\n        }\n      } else {  // Node is not head\n        if (curr.nextf != null) {\n          curr.nextf.prevf = curr.prevf;\n        }\n        curr.prevf.nextf = curr.nextf;\n      }\n      curr = curr.nextv;\n      if (curr != null) {\n        curr.prevv = null;\n      }\n    } while (curr != null);\n  } else {  // Remove all JFaces from vertex\n    var curr = this.head;\n    do {\n      if (curr.prevv == null) {  // Node is head\n        if (curr.nextv == null) {\n          curr.face.conflicts.head = null;\n        } else {\n          curr.nextv.prevv = null;\n          curr.face.conflicts.head = curr.nextv;\n        }\n      } else {  // Node is not head\n        if (curr.nextv != null) {\n          curr.nextv.prevv = curr.prevv;\n        }\n        curr.prevv.nextv = curr.nextv;\n      }\n      curr = curr.nextf;\n      if (curr != null)\n        curr.prevf = null;\n    } while (curr != null);\n  }\n}\n\n// IN: list of vertices\nConflictList.prototype.getVertices = function() {\n  var list = [],\n  \t\tcurr = this.head;\n  while (curr !== null) {\n    list.push(curr.vert);\n    curr = curr.nextv;\n  }\n  return list;\n}", "// Vertex\nimport {epsilon} from './utils';\nimport {ConflictList} from './conflictList';\n\n// IN: coordinates x, y, z\nexport function Vertex (x, y, z, weight, orig, isDummy) {\n  this.x = x;\n  this.y = y;\n  this.weight = epsilon;\n  this.index = 0;\n  this.conflicts = new ConflictList(false);\n  this.neighbours = null;  // Potential trouble\n  this.nonClippedPolygon = null;\n  this.polygon = null;\n  this.originalObject = null;\n  this.isDummy = false;\n\n  if (orig !== undefined) {\n    this.originalObject = orig;\n  }\n  if (isDummy != undefined) {\n    this.isDummy = isDummy;\n  }\n  if (weight != null) {\n    this.weight = weight;\n  }\n  if (z != null) {\n    this.z = z;\n  } else {\n    this.z = this.projectZ(this.x, this.y, this.weight);\n  }\n}\n\nVertex.prototype.projectZ = function(x, y, weight) {\n  return ((x*x) + (y*y) - weight);\n}\n\nVertex.prototype.setWeight = function(weight) {\n  this.weight = weight;\n  this.z = this.projectZ(this.x, this.y, this.weight);\n}\n\nVertex.prototype.subtract = function(v) {\n  return new Vertex(v.x - this.x, v.y - this.y, v.z - this.z);\n}\n\nVertex.prototype.crossproduct = function(v) {\n  return new Vertex((this.y * v.z) - (this.z * v.y), (this.z * v.x) - (this.x * v.z), (this.x * v.y) - (this.y * v.x));\n}\n\nVertex.prototype.equals = function(v) {\n  return (this.x === v.x && this.y === v.y && this.z === v.z);\n}", "// Plane3D and Point2D\n\n// IN: Face face\nexport function Plane3D (face) {\n  var p1 = face.verts[0];\n  var p2 = face.verts[1];\n  var p3 = face.verts[2];\n  this.a = p1.y * (p2.z-p3.z) + p2.y * (p3.z-p1.z) + p3.y * (p1.z-p2.z);\n  this.b = p1.z * (p2.x-p3.x) + p2.z * (p3.x-p1.x) + p3.z * (p1.x-p2.x);\n  this.c = p1.x * (p2.y-p3.y) + p2.x * (p3.y-p1.y) + p3.x * (p1.y-p2.y);\n  this.d = -1 * (p1.x * (p2.y*p3.z - p3.y*p2.z) + p2.x * (p3.y*p1.z - p1.y*p3.z) + p3.x * (p1.y*p2.z - p2.y*p1.z));\t\n}\n\nPlane3D.prototype.getNormZPlane = function() {\n  return [\n    -1 * (this.a / this.c),\n    -1 * (this.b / this.c),\n    -1 * (this.d / this.c)\n  ];\n}\n\n// OUT: point2D\nPlane3D.prototype.getDualPointMappedToPlane = function() {\n  var nplane = this.getNormZPlane();\n  var dualPoint = new Point2D(nplane[0]/2, nplane[1]/2);\n  return dualPoint;\n}\n\n// IN: doubles x and y\nexport function Point2D (x, y) {\n  this.x = x;\n  this.y = y;\n}", "// Vector\n\n// IN: coordinates x, y, z\nexport function Vector (x, y, z) {\n  this.x = x;\n  this.y = y;\n  this.z = z;\n}\n\nVector.prototype.negate = function() {\n  this.x *= -1;\n  this.y *= -1;\n  this.z *= -1;\n}\n\n// Normalizes X Y and Z in-place\nVector.prototype.normalize = function() {\n  var lenght = Math.sqrt((this.x * this.x) + (this.y * this.y) + (this.z * this.z));\n  if (lenght > 0) {\n    this.x /= lenght;\n    this.y /= lenght;\n    this.z /= lenght;\n  }\n}", "// HEdge\n\n// IN: vertex orig, vertex dest, Face face\nexport function HEdge (orig, dest, face) {\n  this.next = null;\n  this.prev = null;\n  this.twin = null;\n  this.orig = orig;\n  this.dest = dest;\n  this.iFace = face;\n}\n\nHEdge.prototype.isHorizon = function() {\n  return this.twin !== null && !this.iFace.marked && this.twin.iFace.marked;\n}\n\n// IN: array horizon\nHEdge.prototype.findHorizon = function(horizon) {\n  if (this.isHorizon()) {\n    if (horizon.length > 0 && this === horizon[0]) {\n      return;\n    } else {\n      horizon.push(this);\n      this.next.findHorizon(horizon);\n    }\n  } else {\n    if (this.twin !== null) {\n      this.twin.next.findHorizon(horizon);\n    }\n  }\n}\n\n// IN: vertices origin and dest\nHEdge.prototype.isEqual = function(origin, dest) {\n  return ((this.orig.equals(origin) && this.dest.equals(dest)) || (this.orig.equals(dest) && this.dest.equals(origin)));\n}", "// from https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript\n// (above link provided by https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)\n\nexport default function d3WeightedVoronoiError(message) {\n  this.message = message;\n  this.stack = new Error().stack;\n}\n\nd3WeightedVoronoiError.prototype.name = 'd3WeightedVoronoiError';\nd3WeightedVoronoiError.prototype = new Error();\n", "// Face\n\nimport { epsilon, dot } from './utils';\nimport { Plane3D } from './plane3D';\nimport { ConflictList } from './conflictList';\nimport { Vector } from './vector';\nimport { HEdge } from './hEdge';\nimport d3WeightedVoronoiError from './d3-weighted-voronoi-error';\n\n// IN: Vertices a, b, c\nexport function Face(a, b, c, orient) {\n  this.conflicts = new ConflictList(true);\n  this.verts = [a, b, c];\n  this.marked = false;\n  var t = a.subtract(b).crossproduct(b.subtract(c));\n\n  this.normal = new Vector(-t.x, -t.y, -t.z);\n  this.normal.normalize();\n  this.createEdges();\n  this.dualPoint = null;\n\n  if (orient != undefined) {\n    this.orient(orient);\n  }\n}\n\n// OUT: Point2D\nFace.prototype.getDualPoint = function () {\n  if (this.dualPoint == null) {\n    var plane3d = new Plane3D(this);\n    this.dualPoint = plane3d.getDualPointMappedToPlane();\n  }\n  return this.dualPoint;\n};\n\nFace.prototype.isVisibleFromBelow = function () {\n  return this.normal.z < -1.4259414393190911e-9;\n};\n\nFace.prototype.createEdges = function () {\n  this.edges = [];\n  this.edges[0] = new HEdge(this.verts[0], this.verts[1], this);\n  this.edges[1] = new HEdge(this.verts[1], this.verts[2], this);\n  this.edges[2] = new HEdge(this.verts[2], this.verts[0], this);\n  this.edges[0].next = this.edges[1];\n  this.edges[0].prev = this.edges[2];\n  this.edges[1].next = this.edges[2];\n  this.edges[1].prev = this.edges[0];\n  this.edges[2].next = this.edges[0];\n  this.edges[2].prev = this.edges[1];\n};\n\n// IN: vertex orient\nFace.prototype.orient = function (orient) {\n  if (!(dot(this.normal, orient) < dot(this.normal, this.verts[0]))) {\n    var temp = this.verts[1];\n    this.verts[1] = this.verts[2];\n    this.verts[2] = temp;\n    this.normal.negate();\n    this.createEdges();\n  }\n};\n\n// IN: two vertices v0 and v1\nFace.prototype.getEdge = function (v0, v1) {\n  for (var i = 0; i < 3; i++) {\n    if (this.edges[i].isEqual(v0, v1)) {\n      return this.edges[i];\n    }\n  }\n  return null;\n};\n\n// IN: Face face, vertices v0 and v1\nFace.prototype.link = function (face, v0, v1) {\n  if (face instanceof Face) {\n    var twin = face.getEdge(v0, v1);\n    if (twin === null) {\n      throw new d3WeightedVoronoiError('when linking, twin is null');\n    }\n    var edge = this.getEdge(v0, v1);\n    if (edge === null) {\n      throw new d3WeightedVoronoiError('when linking, twin is null');\n    }\n    twin.twin = edge;\n    edge.twin = twin;\n  } else {\n    var twin = face; // face is a hEdge\n    var edge = this.getEdge(twin.orig, twin.dest);\n    twin.twin = edge;\n    edge.twin = twin;\n  }\n};\n\n// IN: vertex v\nFace.prototype.conflict = function (v) {\n  return dot(this.normal, v) > dot(this.normal, this.verts[0]) + epsilon;\n};\n\nFace.prototype.getHorizon = function () {\n  for (var i = 0; i < 3; i++) {\n    if (this.edges[i].twin !== null && this.edges[i].twin.isHorizon()) {\n      return this.edges[i];\n    }\n  }\n  return null;\n};\n\nFace.prototype.removeConflict = function () {\n  this.conflicts.removeAll();\n};\n", "// convexHull.js\nimport { epsilonesque, dot, linearDependent } from './utils';\nimport { ConflictList, ConflictListNode } from './conflictList';\nimport { Vertex } from './vertex';\nimport { Face } from './face';\nimport d3WeightedVoronoiError from './d3-weighted-voronoi-error';\n\nexport function ConvexHull() {\n  this.points = [];\n  this.facets = [];\n  this.created = [];\n  this.horizon = [];\n  this.visible = [];\n  this.current = 0;\n}\n\n// IN: sites (x,y,z)\nConvexHull.prototype.init = function (boundingSites, sites) {\n  this.points = [];\n  for (var i = 0; i < sites.length; i++) {\n    this.points[i] = new Vertex(sites[i].x, sites[i].y, sites[i].z, null, sites[i], false);\n  }\n  this.points = this.points.concat(boundingSites);\n};\n\nConvexHull.prototype.permutate = function () {\n  var pointSize = this.points.length;\n  for (var i = pointSize - 1; i > 0; i--) {\n    var ra = Math.floor(Math.random() * i);\n    var temp = this.points[ra];\n    temp.index = i;\n    var currentItem = this.points[i];\n    currentItem.index = ra;\n    this.points.splice(ra, 1, currentItem);\n    this.points.splice(i, 1, temp);\n  }\n};\n\n(ConvexHull.prototype.prep = function () {\n  if (this.points.length <= 3) {\n    throw new d3WeightedVoronoiError('Less than 4 points');\n  }\n  for (var i = 0; i < this.points.length; i++) {\n    this.points[i].index = i;\n  }\n\n  var v0, v1, v2, v3;\n  var f1, f2, f3, f0;\n  v0 = this.points[0];\n  v1 = this.points[1];\n  v2 = v3 = null;\n\n  // Searching for a third vertex, not aligned with the 2 firsts\n  for (var i = 2; i < this.points.length; i++) {\n    if (!(linearDependent(v0, this.points[i]) && linearDependent(v1, this.points[i]))) {\n      v2 = this.points[i];\n      v2.index = 2;\n      this.points[2].index = i;\n      this.points.splice(i, 1, this.points[2]);\n      this.points.splice(2, 1, v2);\n      break;\n    }\n  }\n  if (v2 === null) {\n    throw new d3WeightedVoronoiError('Not enough non-planar Points (v2 is null)');\n  }\n\n  // Create first JFace\n  f0 = new Face(v0, v1, v2);\n  // Searching for a fourth vertex, not coplanar to the 3 firsts\n  for (var i = 3; i < this.points.length; i++) {\n    if (!epsilonesque(dot(f0.normal, f0.verts[0]) - dot(f0.normal, this.points[i]))) {\n      v3 = this.points[i];\n      v3.index = 3;\n      this.points[3].index = i;\n      this.points.splice(i, 1, this.points[3]);\n      this.points.splice(3, 1, v3);\n      break;\n    }\n  }\n  if (v3 === null) {\n    throw new d3WeightedVoronoiError('Not enough non-planar Points (v3 is null)');\n  }\n\n  f0.orient(v3);\n  f1 = new Face(v0, v2, v3, v1);\n  f2 = new Face(v0, v1, v3, v2);\n  f3 = new Face(v1, v2, v3, v0);\n  this.addFacet(f0);\n  this.addFacet(f1);\n  this.addFacet(f2);\n  this.addFacet(f3);\n  // Connect facets\n  f0.link(f1, v0, v2);\n  f0.link(f2, v0, v1);\n  f0.link(f3, v1, v2);\n  f1.link(f2, v0, v3);\n  f1.link(f3, v2, v3);\n  f2.link(f3, v3, v1);\n  this.current = 4;\n\n  var v;\n  for (var i = this.current; i < this.points.length; i++) {\n    v = this.points[i];\n    if (f0.conflict(v)) {\n      this.addConflict(f0, v);\n    }\n    if (f1.conflict(v)) {\n      this.addConflict(f1, v);\n    }\n    if (f2.conflict(v)) {\n      this.addConflict(f2, v);\n    }\n    if (f3.conflict(v)) {\n      this.addConflict(f3, v);\n    }\n  }\n}),\n  // IN: Faces old1 old2 and fn\n  (ConvexHull.prototype.addConflicts = function (old1, old2, fn) {\n    var l1 = old1.conflicts.getVertices();\n    var l2 = old2.conflicts.getVertices();\n    var nCL = [];\n    var v1, v2;\n    var i, l;\n    i = l = 0;\n    // Fill the possible new Conflict List\n    while (i < l1.length || l < l2.length) {\n      if (i < l1.length && l < l2.length) {\n        v1 = l1[i];\n        v2 = l2[l];\n        // If the index is the same, it's the same vertex and only 1 has to be added\n        if (v1.index === v2.index) {\n          nCL.push(v1);\n          i++;\n          l++;\n        } else if (v1.index > v2.index) {\n          nCL.push(v1);\n          i++;\n        } else {\n          nCL.push(v2);\n          l++;\n        }\n      } else if (i < l1.length) {\n        nCL.push(l1[i++]);\n      } else {\n        nCL.push(l2[l++]);\n      }\n    }\n    // Check if the possible conflicts are real conflicts\n    for (var i = nCL.length - 1; i >= 0; i--) {\n      v1 = nCL[i];\n      if (fn.conflict(v1)) this.addConflict(fn, v1);\n    }\n  });\n\n// IN: Face face, Vertex v\nConvexHull.prototype.addConflict = function (face, vert) {\n  var e = new ConflictListNode(face, vert);\n  face.conflicts.add(e);\n  vert.conflicts.add(e);\n};\n\n// IN: Face f\nConvexHull.prototype.removeConflict = function (f) {\n  f.removeConflict();\n  var index = f.index;\n  f.index = -1;\n  if (index === this.facets.length - 1) {\n    this.facets.splice(this.facets.length - 1, 1);\n    return;\n  }\n  if (index >= this.facets.length || index < 0) return;\n  var last = this.facets.splice(this.facets.length - 1, 1);\n  last[0].index = index;\n  this.facets.splice(index, 1, last[0]);\n};\n\n// IN: Face face\nConvexHull.prototype.addFacet = function (face) {\n  face.index = this.facets.length;\n  this.facets.push(face);\n};\n\nConvexHull.prototype.compute = function () {\n  this.prep();\n  while (this.current < this.points.length) {\n    var next = this.points[this.current];\n    if (next.conflicts.isEmpty()) {\n      // No conflict, point in hull\n      this.current++;\n      continue;\n    }\n    this.created = []; // TODO: make sure this is okay and doesn't dangle references\n    this.horizon = [];\n    this.visible = [];\n    // The visible faces are also marked\n    next.conflicts.fill(this.visible);\n    // Horizon edges are orderly added to the horizon list\n    var e;\n    for (var jF = 0; jF < this.visible.length; jF++) {\n      e = this.visible[jF].getHorizon();\n      if (e !== null) {\n        e.findHorizon(this.horizon);\n        break;\n      }\n    }\n    var last = null,\n      first = null;\n    // Iterate over horizon edges and create new faces oriented with the marked face 3rd unused point\n    for (var hEi = 0; hEi < this.horizon.length; hEi++) {\n      var hE = this.horizon[hEi];\n      var fn = new Face(next, hE.orig, hE.dest, hE.twin.next.dest);\n      fn.conflicts = new ConflictList(true);\n      // Add to facet list\n      this.addFacet(fn);\n      this.created.push(fn);\n      // Add new conflicts\n      this.addConflicts(hE.iFace, hE.twin.iFace, fn);\n      // Link the new face with the horizon edge\n      fn.link(hE);\n      if (last !== null) fn.link(last, next, hE.orig);\n      last = fn;\n      if (first === null) first = fn;\n    }\n    // Links the first and the last created JFace\n    if (first !== null && last !== null) {\n      last.link(first, next, this.horizon[0].orig);\n    }\n    if (this.created.length != 0) {\n      // update conflict graph\n      for (var f = 0; f < this.visible.length; f++) {\n        this.removeConflict(this.visible[f]);\n      }\n      this.current++;\n      this.created = [];\n    }\n  }\n  return this.facets;\n};\n\nConvexHull.prototype.clear = function () {\n  this.points = [];\n  this.facets = [];\n  this.created = [];\n  this.horizon = [];\n  this.visible = [];\n  this.current = 0;\n};\n", "export function polygonClip(clip, subject) {\n  // Version 0.0.0. Copyright 2017 Mike Bostock.\n\n  // Clips the specified subject polygon to the specified clip polygon;\n  // requires the clip polygon to be counterclockwise and convex.\n  // https://en.wikipedia.org/wiki/Sutherland–Hodgman_algorithm\n  // https://observablehq.com/@d3/polygonclip\n\n  var input,\n    closed = polygonClosed(subject),\n    i = -1,\n    n = clip.length - polygonClosed(clip),\n    j,\n    m,\n    a = clip[n - 1],\n    b,\n    c,\n    d,\n    intersection;\n\n  while (++i < n) {\n    input = subject.slice();\n    subject.length = 0;\n    b = clip[i];\n    c = input[(m = input.length - closed) - 1];\n    j = -1;\n    while (++j < m) {\n      d = input[j];\n      if (polygonInside(d, a, b)) {\n        if (!polygonInside(c, a, b)) {\n          intersection = polygonIntersect(c, d, a, b);\n          if (isFinite(intersection[0])) {\n            subject.push(intersection);\n          }\n        }\n        subject.push(d);\n      } else if (polygonInside(c, a, b)) {\n        intersection = polygonIntersect(c, d, a, b);\n        if (isFinite(intersection[0])) {\n          subject.push(intersection);\n        }\n      }\n      c = d;\n    }\n    if (closed) subject.push(subject[0]);\n    a = b;\n  }\n\n  return subject;\n}\n\nfunction polygonInside(p, a, b) {\n  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n}\n\n// Intersect two infinite lines cd and ab.\n// Return Infinity if cd and ab colinear\nfunction polygonIntersect(c, d, a, b) {\n  var x1 = c[0],\n    x3 = a[0],\n    x21 = d[0] - x1,\n    x43 = b[0] - x3,\n    y1 = c[1],\n    y3 = a[1],\n    y21 = d[1] - y1,\n    y43 = b[1] - y3,\n    ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n  return [x1 + ua * x21, y1 + ua * y21];\n}\n\n// Returns true if the polygon is closed.\nfunction polygonClosed(coordinates) {\n  var a = coordinates[0],\n    b = coordinates[coordinates.length - 1];\n  return !(a[0] - b[0] || a[1] - b[1]);\n}\n", "// powerDiagram.js - computePowerDiagramIntegrated() and subroutines\nimport {polygonLength} from 'd3-polygon';\nimport {epsilon} from './utils';\nimport {Vertex} from './vertex';\nimport {ConvexHull} from './convexHull';\nimport {polygonClip} from './d3-polygon-clip';\n\n// IN: HEdge edge\nfunction getFacesOfDestVertex(edge) {\n  var faces = [];\n  var previous = edge;\n  var first = edge.dest;\n  var site = first.originalObject;\n  var neighbours = [];\n  do {\n    previous = previous.twin.prev;\n    var siteOrigin = previous.orig.originalObject;\n    if (!siteOrigin.isDummy) {\n      neighbours.push(siteOrigin);\n    }\n    var iFace = previous.iFace;\n    if (iFace.isVisibleFromBelow()) {\n      faces.push(iFace);\n    }\n  } while (previous !== edge);\n  site.neighbours = neighbours;\n  return faces;\n}\n\n// IN: Omega = convex bounding polygon\n// IN: S = unique set of sites with weights\n// OUT: Set of lines making up the voronoi power diagram\nexport function computePowerDiagramIntegrated (sites, boundingSites, clippingPolygon) {\n  var convexHull = new ConvexHull();\n  convexHull.clear();\n  convexHull.init(boundingSites, sites);\n\n  var facets = convexHull.compute(sites);\n  var polygons = []; \n  var verticesVisited = [];\n  var facetCount = facets.length;\n\n  for (var i = 0; i < facetCount; i++) {\n    var facet = facets[i];\n    if (facet.isVisibleFromBelow()) {\n      for (var e = 0; e < 3; e++) {\n        // go through the edges and start to build the polygon by going through the double connected edge list\n        var edge = facet.edges[e];\n        var destVertex = edge.dest;\n        var site = destVertex.originalObject; \n\n        if (!verticesVisited[destVertex.index]) {\n          verticesVisited[destVertex.index] = true;\n          if (site.isDummy) {\n            // Check if this is one of the sites making the bounding polygon\n            continue;\n          }\n          // faces around the vertices which correspond to the polygon corner points\n          var faces = getFacesOfDestVertex(edge);\n          var protopoly = [];\n          var lastX = null;\n          var lastY = null;\n          var dx = 1;\n          var dy = 1;\n          for (var j = 0; j < faces.length; j++) {\n            var point = faces[j].getDualPoint();\n            var x1 = point.x;\n            var y1 = point.y;\n            if (lastX !== null) {\n              dx = lastX - x1;\n              dy = lastY - y1;\n              if (dx < 0) {\n                dx = -dx;\n              }\n              if (dy < 0) {\n                dy = -dy;\n              }\n            }\n            if (dx > epsilon || dy > epsilon) {\n              protopoly.push([x1, y1]);\n              lastX = x1;\n              lastY = y1;\n            }\n          }\n          \n          site.nonClippedPolygon = protopoly.reverse();\n          if (!site.isDummy && polygonLength(site.nonClippedPolygon) > 0) {\n            var clippedPoly = polygonClip(clippingPolygon, site.nonClippedPolygon);\n            site.polygon = clippedPoly;\n            clippedPoly.site = site;\n            if (clippedPoly.length > 0) {\n              polygons.push(clippedPoly);\n            }\n          }\n        }\n      }\n    }\n  }\n  return polygons;\n}\n", "import { extent as d3Extent } from 'd3-array';\nimport { polygonHull as d3PolygonHull } from 'd3-polygon';\nimport { epsilon, polygonDirection } from './utils';\nimport { Vertex } from './vertex';\nimport { computePowerDiagramIntegrated } from './powerDiagram';\n\nexport function weightedVoronoi() {\n  /////// Inputs ///////\n  var x = function (d) {\n    return d.x;\n  }; // accessor to the x value\n  var y = function (d) {\n    return d.y;\n  }; // accessor to the y value\n  var weight = function (d) {\n    return d.weight;\n  }; // accessor to the weight\n  var clip = [\n    [0, 0],\n    [0, 1],\n    [1, 1],\n    [1, 0],\n  ]; // clipping polygon\n  var extent = [\n    [0, 0],\n    [1, 1],\n  ]; // extent of the clipping polygon\n  var size = [1, 1]; // [width, height] of the clipping polygon\n\n  ///////////////////////\n  ///////// API /////////\n  ///////////////////////\n\n  function _weightedVoronoi(data) {\n    var formatedSites;\n\n    //begin: map sites to the expected format of PowerDiagram\n    formatedSites = data.map(function (d) {\n      return new Vertex(x(d), y(d), null, weight(d), d, false);\n    });\n    //end: map sites to the expected format of PowerDiagram\n\n    return computePowerDiagramIntegrated(formatedSites, boundingSites(), clip);\n  }\n\n  _weightedVoronoi.x = function (_) {\n    if (!arguments.length) {\n      return x;\n    }\n\n    x = _;\n    return _weightedVoronoi;\n  };\n\n  _weightedVoronoi.y = function (_) {\n    if (!arguments.length) {\n      return y;\n    }\n\n    y = _;\n    return _weightedVoronoi;\n  };\n\n  _weightedVoronoi.weight = function (_) {\n    if (!arguments.length) {\n      return weight;\n    }\n\n    weight = _;\n    return _weightedVoronoi;\n  };\n\n  _weightedVoronoi.clip = function (_) {\n    var direction, xExtent, yExtent;\n\n    if (!arguments.length) {\n      return clip;\n    }\n\n    xExtent = d3Extent(\n      _.map(function (c) {\n        return c[0];\n      })\n    );\n    yExtent = d3Extent(\n      _.map(function (c) {\n        return c[1];\n      })\n    );\n    direction = polygonDirection(_);\n    if (direction === undefined) {\n      clip = d3PolygonHull(_); // ensure clip to be a convex, hole-free, counterclockwise polygon\n    } else if (direction === 1) {\n      clip = _.reverse(); // already convex, order array in the same direction as d3-polygon.polygonHull(...)\n    } else {\n      clip = _;\n    }\n    extent = [\n      [xExtent[0], yExtent[0]],\n      [xExtent[1], yExtent[1]],\n    ];\n    size = [xExtent[1] - xExtent[0], yExtent[1] - yExtent[0]];\n    return _weightedVoronoi;\n  };\n\n  _weightedVoronoi.extent = function (_) {\n    if (!arguments.length) {\n      return extent;\n    }\n\n    clip = [_[0], [_[0][0], _[1][1]], _[1], [_[1][0], _[0][1]]];\n    extent = _;\n    size = [_[1][0] - _[0][0], _[1][1] - _[0][1]];\n    return _weightedVoronoi;\n  };\n\n  _weightedVoronoi.size = function (_) {\n    if (!arguments.length) {\n      return size;\n    }\n\n    clip = [\n      [0, 0],\n      [0, _[1]],\n      [_[0], _[1]],\n      [_[0], 0],\n    ];\n    extent = [[0, 0], _];\n    size = _;\n    return _weightedVoronoi;\n  };\n\n  ///////////////////////\n  /////// Private ///////\n  ///////////////////////\n\n  function boundingSites() {\n    var minX,\n      maxX,\n      minY,\n      maxY,\n      width,\n      height,\n      x0,\n      x1,\n      y0,\n      y1,\n      boundingData = [],\n      boundingSites = [];\n\n    minX = extent[0][0];\n    maxX = extent[1][0];\n    minY = extent[0][1];\n    maxY = extent[1][1];\n    width = maxX - minX;\n    height = maxY - minY;\n    x0 = minX - width;\n    x1 = maxX + width;\n    y0 = minY - height;\n    y1 = maxY + height;\n\n    // MUST be counterclockwise\n    // if not, may produce 'TypeError: Cannot set property 'twin' of null' during computation\n    // don't know how to test as it is not exposed\n    boundingData[0] = [x0, y0];\n    boundingData[1] = [x0, y1];\n    boundingData[2] = [x1, y1];\n    boundingData[3] = [x1, y0];\n\n    for (var i = 0; i < 4; i++) {\n      boundingSites.push(\n        new Vertex(\n          boundingData[i][0],\n          boundingData[i][1],\n          null,\n          epsilon,\n          new Vertex(boundingData[i][0], boundingData[i][1], null, epsilon, null, true),\n          true\n        )\n      );\n    }\n\n    return boundingSites;\n  }\n\n  return _weightedVoronoi;\n}\n", "\nexport function FlickeringMitigation () {\n  /////// Inputs ///////\n  this.growthChangesLength = DEFAULT_LENGTH;\n  this.totalAvailableArea = NaN;\n\n  //begin: internals\n  this.lastAreaError = NaN;\n  this.lastGrowth = NaN;\n  this.growthChanges = [];\n  this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength); //used to make recent changes weighter than older changes\n  this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);\n  //end: internals\n}\n\nvar DEFAULT_LENGTH = 10;\n\nfunction direction(h0, h1) {\n  return (h0 >= h1)? 1 : -1;\n}\n\nfunction generateGrowthChangeWeights(length) {\n  var initialWeight = 3;   // a magic number\n  var weightDecrement = 1; // a magic number\n  var minWeight = 1;\n\n  var weightedCount = initialWeight;\n  var growthChangeWeights = [];\n\n  for (var i=0; i<length; i++) {\n    growthChangeWeights.push(weightedCount);\n    weightedCount -= weightDecrement;\n    if (weightedCount<minWeight) { weightedCount = minWeight; }\n  }\n  return growthChangeWeights;\n}\n\nfunction computeGrowthChangeWeightsSum (growthChangeWeights) {\n  var growthChangeWeightsSum = 0;\n  for (var i=0; i<growthChangeWeights.length; i++) {\n    growthChangeWeightsSum += growthChangeWeights[i];\n  }\n  return growthChangeWeightsSum;\n}\n\n///////////////////////\n///////// API /////////\n///////////////////////\n\nFlickeringMitigation.prototype.reset = function () {\n  this.lastAreaError = NaN;\n  this.lastGrowth = NaN;\n  this.growthChanges = [];\n  this.growthChangesLength = DEFAULT_LENGTH;\n  this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);\n  this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);\n  this.totalAvailableArea = NaN;\n\n  return this;\n};\n\nFlickeringMitigation.prototype.clear = function () {\n  this.lastAreaError = NaN;\n  this.lastGrowth = NaN;\n  this.growthChanges = [];\n\n  return this;\n};\n\nFlickeringMitigation.prototype.length = function (_) {\n  if (!arguments.length) { return this.growthChangesLength; }\n\n  if (parseInt(_)>0) {\n    this.growthChangesLength = Math.floor(parseInt(_));\n    this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);\n    this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);\n  } else {\n    console.warn(\"FlickeringMitigation.length() accepts only positive integers; unable to handle \"+_);\n  }\n  return this;\n};\n\nFlickeringMitigation.prototype.totalArea = function (_) {\n  if (!arguments.length) { return this.totalAvailableArea; }\n\n  if (parseFloat(_)>0) {\n    this.totalAvailableArea = parseFloat(_);\n  } else {\n    console.warn(\"FlickeringMitigation.totalArea() accepts only positive numbers; unable to handle \"+_);\n  }\n  return this;\n};\n\nFlickeringMitigation.prototype.add = function (areaError) {\n  var secondToLastAreaError, secondToLastGrowth;\n\n  secondToLastAreaError = this.lastAreaError;\n  this.lastAreaError = areaError;\n  if (!isNaN(secondToLastAreaError)) {\n    secondToLastGrowth = this.lastGrowth;\n    this.lastGrowth = direction(this.lastAreaError, secondToLastAreaError);\n  }\n  if (!isNaN(secondToLastGrowth)) {\n    this.growthChanges.unshift(this.lastGrowth!=secondToLastGrowth);\n  }\n\n  if (this.growthChanges.length>this.growthChangesLength) {\n    this.growthChanges.pop();\n  }\n  return this;\n};\n\nFlickeringMitigation.prototype.ratio = function () {\n  var weightedChangeCount = 0;\n  var ratio;\n\n  if (this.growthChanges.length < this.growthChangesLength) { return 0; }\n  if (this.lastAreaError > this.totalAvailableArea/10) { return 0; }\n\n  for(var i=0; i<this.growthChangesLength; i++) {\n    if (this.growthChanges[i]) {\n      weightedChangeCount += this.growthChangeWeights[i];\n    }\n  }\n\n  ratio = weightedChangeCount/this.growthChangeWeightsSum;\n\n  /*\n  if (ratio>0) {\n    console.log(\"flickering mitigation ratio: \"+Math.floor(ratio*1000)/1000);\n  }\n  */\n\n  return ratio;\n};", "import {\n  polygonContains as d3PolygonContains\n} from 'd3-polygon';\n\nexport default function () {\n\n  //begin: internals\n  var clippingPolygon,\n    extent,\n    minX, maxX,\n    minY, maxY,\n    dx, dy;\n  //end: internals\n\n  ///////////////////////\n  ///////// API /////////\n  ///////////////////////\n\n  function _random(d, i, arr, voronoiMapSimulation) {\n    var shouldUpdateInternals = false;\n    var x, y;\n\n    if (clippingPolygon !== voronoiMapSimulation.clip()) {\n      clippingPolygon = voronoiMapSimulation.clip();\n      extent = voronoiMapSimulation.extent();\n      shouldUpdateInternals = true;\n    }\n\n    if (shouldUpdateInternals) {\n      updateInternals();\n    }\n\n    x = minX + dx * voronoiMapSimulation.prng()();\n    y = minY + dy * voronoiMapSimulation.prng()();\n    while (!d3PolygonContains(clippingPolygon, [x, y])) {\n      x = minX + dx * voronoiMapSimulation.prng()();\n      y = minY + dy * voronoiMapSimulation.prng()();\n    }\n    return [x, y];\n  };\n\n  ///////////////////////\n  /////// Private ///////\n  ///////////////////////\n\n  function updateInternals() {\n    minX = extent[0][0];\n    maxX = extent[1][0];\n    minY = extent[0][1];\n    maxY = extent[1][1];\n    dx = maxX - minX;\n    dy = maxY - minY;\n  };\n\n  return _random;\n};", "import {\n  polygonArea as d3PolygonArea\n} from 'd3-polygon';\n\nexport default function () {\n  //begin: internals\n  var clippingPolygon,\n    dataArray,\n    siteCount,\n    totalArea,\n    halfAverageArea;\n  //end: internals\n\n  ///////////////////////\n  ///////// API /////////\n  ///////////////////////\n  function _halfAverageArea(d, i, arr, voronoiMapSimulation) {\n    var shouldUpdateInternals = false;\n    if (clippingPolygon !== voronoiMapSimulation.clip()) {\n      clippingPolygon = voronoiMapSimulation.clip();\n      shouldUpdateInternals |= true;\n    }\n    if (dataArray !== arr) {\n      dataArray = arr;\n      shouldUpdateInternals |= true;\n    }\n\n    if (shouldUpdateInternals) {\n      updateInternals();\n    }\n\n    return halfAverageArea;\n  };\n\n  ///////////////////////\n  /////// Private ///////\n  ///////////////////////\n\n  function updateInternals() {\n    siteCount = dataArray.length;\n    totalArea = d3PolygonArea(clippingPolygon);\n    halfAverageArea = totalArea / siteCount / 2; // half of the average area of the the clipping polygon\n  }\n\n  return _halfAverageArea;\n};", "// from https://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript\n// (above link provided by https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)\n\nexport default function d3VoronoiMapError(message) {\n  this.message = message;\n  this.stack = new Error().stack;\n}\n\nd3VoronoiMapError.prototype.name = 'd3VoronoiMapError';\nd3VoronoiMapError.prototype = new Error();\n", "import {\n  polygonCentroid as d3PolygonCentroid,\n  polygonArea as d3PolygonArea,\n  polygonContains as d3PolygonContains,\n} from 'd3-polygon';\nimport { timer as d3Timer } from 'd3-timer';\nimport { dispatch as d3Dispatch } from 'd3-dispatch';\nimport { weightedVoronoi as d3WeightedVoronoi } from 'd3-weighted-voronoi';\nimport { FlickeringMitigation } from './flickering-mitigation';\nimport randomInitialPosition from './initial-position-policies/random';\nimport pieInitialPosition from './initial-position-policies/pie';\nimport halfAverageAreaInitialWeight from './initial-weight-policies/half-average-area';\nimport d3VoronoiMapError from './d3-voronoi-map-error';\n\nexport function voronoiMapSimulation(data) {\n  //begin: constants\n  var DEFAULT_CONVERGENCE_RATIO = 0.01;\n  var DEFAULT_MAX_ITERATION_COUNT = 50;\n  var DEFAULT_MIN_WEIGHT_RATIO = 0.01;\n  var DEFAULT_PRNG = Math.random;\n  var DEFAULT_INITIAL_POSITION = randomInitialPosition();\n  var DEFAULT_INITIAL_WEIGHT = halfAverageAreaInitialWeight();\n  var RANDOM_INITIAL_POSITION = randomInitialPosition();\n  var epsilon = 1e-10;\n  //end: constants\n\n  /////// Inputs ///////\n  var weight = function (d) {\n    return d.weight;\n  }; // accessor to the weight\n  var convergenceRatio = DEFAULT_CONVERGENCE_RATIO; // targeted allowed error ratio; default 0.01 stops computation when cell areas error <= 1% clipping polygon's area\n  var maxIterationCount = DEFAULT_MAX_ITERATION_COUNT; // maximum allowed iteration; stops computation even if convergence is not reached; use a large amount for a sole converge-based computation stop\n  var minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO; // used to compute the minimum allowed weight; default 0.01 means 1% of max weight; handle near-zero weights, and leaves enought space for cell hovering\n  var prng = DEFAULT_PRNG; // pseudorandom number generator\n  var initialPosition = DEFAULT_INITIAL_POSITION; // accessor to the initial position; defaults to a random position inside the clipping polygon\n  var initialWeight = DEFAULT_INITIAL_WEIGHT; // accessor to the initial weight; defaults to the average area of the clipping polygon\n\n  //begin: internals\n  var weightedVoronoi = d3WeightedVoronoi(),\n    flickeringMitigation = new FlickeringMitigation(),\n    shouldInitialize = true, // should initialize due to changes via APIs\n    siteCount, // number of sites\n    totalArea, // area of the clipping polygon\n    areaErrorTreshold, // targeted allowed area error (= totalArea * convergenceRatio); below this treshold, map is considered obtained and computation stops\n    iterationCount, // current iteration\n    polygons, // current computed polygons\n    areaError, // current area error\n    converged, // true if (areaError < areaErrorTreshold)\n    ended; // stores if computation is ended, either if computation has converged or if it has reached the maximum allowed iteration\n  //end: internals\n  //being: internals/simulation\n  var simulation,\n    stepper = d3Timer(step),\n    event = d3Dispatch('tick', 'end');\n  //end: internals/simulation\n\n  //begin: algorithm conf.\n  const HANDLE_OVERWEIGHTED_VARIANT = 1; // this option still exists 'cause for further experiments\n  const HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT = 1000; // max number of tries to handle overweigthed sites\n  var handleOverweighted;\n  //end: algorithm conf.\n\n  //begin: utils\n  function sqr(d) {\n    return Math.pow(d, 2);\n  }\n\n  function squaredDistance(s0, s1) {\n    return sqr(s1.x - s0.x) + sqr(s1.y - s0.y);\n  }\n  //end: utils\n\n  ///////////////////////\n  ///////// API /////////\n  ///////////////////////\n\n  simulation = {\n    tick: tick,\n\n    restart: function () {\n      stepper.restart(step);\n      return simulation;\n    },\n\n    stop: function () {\n      stepper.stop();\n      return simulation;\n    },\n\n    weight: function (_) {\n      if (!arguments.length) {\n        return weight;\n      }\n\n      weight = _;\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    convergenceRatio: function (_) {\n      if (!arguments.length) {\n        return convergenceRatio;\n      }\n\n      convergenceRatio = _;\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    maxIterationCount: function (_) {\n      if (!arguments.length) {\n        return maxIterationCount;\n      }\n\n      maxIterationCount = _;\n      return simulation;\n    },\n\n    minWeightRatio: function (_) {\n      if (!arguments.length) {\n        return minWeightRatio;\n      }\n\n      minWeightRatio = _;\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    clip: function (_) {\n      if (!arguments.length) {\n        return weightedVoronoi.clip();\n      }\n\n      weightedVoronoi.clip(_);\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    extent: function (_) {\n      if (!arguments.length) {\n        return weightedVoronoi.extent();\n      }\n\n      weightedVoronoi.extent(_);\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    size: function (_) {\n      if (!arguments.length) {\n        return weightedVoronoi.size();\n      }\n\n      weightedVoronoi.size(_);\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    prng: function (_) {\n      if (!arguments.length) {\n        return prng;\n      }\n\n      prng = _;\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    initialPosition: function (_) {\n      if (!arguments.length) {\n        return initialPosition;\n      }\n\n      initialPosition = _;\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    initialWeight: function (_) {\n      if (!arguments.length) {\n        return initialWeight;\n      }\n\n      initialWeight = _;\n      shouldInitialize = true;\n      return simulation;\n    },\n\n    state: function () {\n      if (shouldInitialize) {\n        initializeSimulation();\n      }\n      return {\n        ended: ended,\n        iterationCount: iterationCount,\n        convergenceRatio: areaError / totalArea,\n        polygons: polygons,\n      };\n    },\n\n    on: function (name, _) {\n      if (arguments.length === 1) {\n        return event.on(name);\n      }\n\n      event.on(name, _);\n      return simulation;\n    },\n  };\n\n  ///////////////////////\n  /////// Private ///////\n  ///////////////////////\n\n  //begin: simulation's main loop\n  function step() {\n    tick();\n    event.call('tick', simulation);\n    if (ended) {\n      stepper.stop();\n      event.call('end', simulation);\n    }\n  }\n  //end: simulation's main loop\n\n  //begin: algorithm used at each iteration\n  function tick() {\n    if (!ended) {\n      if (shouldInitialize) {\n        initializeSimulation();\n      }\n      polygons = adapt(polygons, flickeringMitigation.ratio());\n      iterationCount++;\n      areaError = computeAreaError(polygons);\n      flickeringMitigation.add(areaError);\n      converged = areaError < areaErrorTreshold;\n      ended = converged || iterationCount >= maxIterationCount;\n      // console.log(\"error %: \"+Math.round(areaError*100*1000/totalArea)/1000);\n    }\n  }\n  //end: algorithm used at each iteration\n\n  function initializeSimulation() {\n    //begin: handle algorithm's variants\n    setHandleOverweighted();\n    //end: handle algorithm's variants\n\n    siteCount = data.length;\n    totalArea = Math.abs(d3PolygonArea(weightedVoronoi.clip()));\n    areaErrorTreshold = convergenceRatio * totalArea;\n    flickeringMitigation.clear().totalArea(totalArea);\n\n    iterationCount = 0;\n    converged = false;\n    polygons = initialize(data, simulation);\n    ended = false;\n    shouldInitialize = false;\n  }\n\n  function initialize(data, simulation) {\n    var maxWeight = data.reduce(function (max, d) {\n        return Math.max(max, weight(d));\n      }, -Infinity),\n      minAllowedWeight = maxWeight * minWeightRatio;\n    var weights, mapPoints;\n\n    //begin: extract weights\n    weights = data.map(function (d, i, arr) {\n      return {\n        index: i,\n        weight: Math.max(weight(d), minAllowedWeight),\n        initialPosition: initialPosition(d, i, arr, simulation),\n        initialWeight: initialWeight(d, i, arr, simulation),\n        originalData: d,\n      };\n    });\n    //end: extract weights\n\n    // create map-related points\n    // (with targetedArea, initial position and initialWeight)\n    mapPoints = createMapPoints(weights, simulation);\n    handleOverweighted(mapPoints);\n    return weightedVoronoi(mapPoints);\n  }\n\n  function createMapPoints(basePoints, simulation) {\n    var totalWeight = basePoints.reduce(function (acc, bp) {\n      return (acc += bp.weight);\n    }, 0);\n    var initialPosition;\n\n    return basePoints.map(function (bp, i, bps) {\n      initialPosition = bp.initialPosition;\n\n      if (!d3PolygonContains(weightedVoronoi.clip(), initialPosition)) {\n        initialPosition = DEFAULT_INITIAL_POSITION(bp, i, bps, simulation);\n      }\n\n      return {\n        index: bp.index,\n        targetedArea: (totalArea * bp.weight) / totalWeight,\n        data: bp,\n        x: initialPosition[0],\n        y: initialPosition[1],\n        weight: bp.initialWeight, // ArlindNocaj/Voronoi-Treemap-Library uses an epsilonesque initial weight; using heavier initial weights allows faster weight adjustements, hence faster stabilization\n      };\n    });\n  }\n\n  function adapt(polygons, flickeringMitigationRatio) {\n    var adaptedMapPoints;\n\n    adaptPositions(polygons, flickeringMitigationRatio);\n    adaptedMapPoints = polygons.map(function (p) {\n      return p.site.originalObject;\n    });\n    polygons = weightedVoronoi(adaptedMapPoints);\n    if (polygons.length < siteCount) {\n      throw new d3VoronoiMapError('at least 1 site has no area, which is not supposed to arise');\n    }\n\n    adaptWeights(polygons, flickeringMitigationRatio);\n    adaptedMapPoints = polygons.map(function (p) {\n      return p.site.originalObject;\n    });\n    polygons = weightedVoronoi(adaptedMapPoints);\n    if (polygons.length < siteCount) {\n      throw new d3VoronoiMapError('at least 1 site has no area, which is not supposed to arise');\n    }\n\n    return polygons;\n  }\n\n  function adaptPositions(polygons, flickeringMitigationRatio) {\n    var newMapPoints = [],\n      flickeringInfluence = 0.5;\n    var flickeringMitigation, d, polygon, mapPoint, centroid, dx, dy;\n\n    flickeringMitigation = flickeringInfluence * flickeringMitigationRatio;\n    d = 1 - flickeringMitigation; // in [0.5, 1]\n    for (var i = 0; i < siteCount; i++) {\n      polygon = polygons[i];\n      mapPoint = polygon.site.originalObject;\n      centroid = d3PolygonCentroid(polygon);\n\n      dx = centroid[0] - mapPoint.x;\n      dy = centroid[1] - mapPoint.y;\n\n      //begin: handle excessive change;\n      dx *= d;\n      dy *= d;\n      //end: handle excessive change;\n\n      mapPoint.x += dx;\n      mapPoint.y += dy;\n\n      newMapPoints.push(mapPoint);\n    }\n\n    handleOverweighted(newMapPoints);\n  }\n\n  function adaptWeights(polygons, flickeringMitigationRatio) {\n    var newMapPoints = [],\n      flickeringInfluence = 0.1;\n    var flickeringMitigation, polygon, mapPoint, currentArea, adaptRatio, adaptedWeight;\n\n    flickeringMitigation = flickeringInfluence * flickeringMitigationRatio;\n    for (var i = 0; i < siteCount; i++) {\n      polygon = polygons[i];\n      mapPoint = polygon.site.originalObject;\n      currentArea = d3PolygonArea(polygon);\n      adaptRatio = mapPoint.targetedArea / currentArea;\n\n      //begin: handle excessive change;\n      adaptRatio = Math.max(adaptRatio, 1 - flickeringInfluence + flickeringMitigation); // in [(1-flickeringInfluence), 1]\n      adaptRatio = Math.min(adaptRatio, 1 + flickeringInfluence - flickeringMitigation); // in [1, (1+flickeringInfluence)]\n      //end: handle excessive change;\n\n      adaptedWeight = mapPoint.weight * adaptRatio;\n      adaptedWeight = Math.max(adaptedWeight, epsilon);\n\n      mapPoint.weight = adaptedWeight;\n\n      newMapPoints.push(mapPoint);\n    }\n\n    handleOverweighted(newMapPoints);\n  }\n\n  // heuristics: lower heavy weights\n  function handleOverweighted0(mapPoints) {\n    var fixCount = 0;\n    var fixApplied, tpi, tpj, weightest, lightest, sqrD, adaptedWeight;\n    do {\n      if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {\n        throw new d3VoronoiMapError('handleOverweighted0 is looping too much');\n      }\n      fixApplied = false;\n      for (var i = 0; i < siteCount; i++) {\n        tpi = mapPoints[i];\n        for (var j = i + 1; j < siteCount; j++) {\n          tpj = mapPoints[j];\n          if (tpi.weight > tpj.weight) {\n            weightest = tpi;\n            lightest = tpj;\n          } else {\n            weightest = tpj;\n            lightest = tpi;\n          }\n          sqrD = squaredDistance(tpi, tpj);\n          if (sqrD < weightest.weight - lightest.weight) {\n            // adaptedWeight = sqrD - epsilon; // as in ArlindNocaj/Voronoi-Treemap-Library\n            // adaptedWeight = sqrD + lightest.weight - epsilon; // works, but below heuristics performs better (less flickering)\n            adaptedWeight = sqrD + lightest.weight / 2;\n            adaptedWeight = Math.max(adaptedWeight, epsilon);\n            weightest.weight = adaptedWeight;\n            fixApplied = true;\n            fixCount++;\n            break;\n          }\n        }\n        if (fixApplied) {\n          break;\n        }\n      }\n    } while (fixApplied);\n\n    /*\n    if (fixCount > 0) {\n      console.log('# fix: ' + fixCount);\n    }\n    */\n  }\n\n  // heuristics: increase light weights\n  function handleOverweighted1(mapPoints) {\n    var fixCount = 0;\n    var fixApplied, tpi, tpj, weightest, lightest, sqrD, overweight;\n    do {\n      if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {\n        throw new d3VoronoiMapError('handleOverweighted1 is looping too much');\n      }\n      fixApplied = false;\n      for (var i = 0; i < siteCount; i++) {\n        tpi = mapPoints[i];\n        for (var j = i + 1; j < siteCount; j++) {\n          tpj = mapPoints[j];\n          if (tpi.weight > tpj.weight) {\n            weightest = tpi;\n            lightest = tpj;\n          } else {\n            weightest = tpj;\n            lightest = tpi;\n          }\n          sqrD = squaredDistance(tpi, tpj);\n          if (sqrD < weightest.weight - lightest.weight) {\n            overweight = weightest.weight - lightest.weight - sqrD;\n            lightest.weight += overweight + epsilon;\n            fixApplied = true;\n            fixCount++;\n            break;\n          }\n        }\n        if (fixApplied) {\n          break;\n        }\n      }\n    } while (fixApplied);\n\n    /*\n    if (fixCount > 0) {\n      console.log('# fix: ' + fixCount);\n    }\n    */\n  }\n\n  function computeAreaError(polygons) {\n    //convergence based on summation of all sites current areas\n    var areaErrorSum = 0;\n    var polygon, mapPoint, currentArea;\n    for (var i = 0; i < siteCount; i++) {\n      polygon = polygons[i];\n      mapPoint = polygon.site.originalObject;\n      currentArea = d3PolygonArea(polygon);\n      areaErrorSum += Math.abs(mapPoint.targetedArea - currentArea);\n    }\n    return areaErrorSum;\n  }\n\n  function setHandleOverweighted() {\n    switch (HANDLE_OVERWEIGHTED_VARIANT) {\n      case 0:\n        handleOverweighted = handleOverweighted0;\n        break;\n      case 1:\n        handleOverweighted = handleOverweighted1;\n        break;\n      default:\n        console.error(\"unknown 'handleOverweighted' variant; using variant #1\");\n        handleOverweighted = handleOverweighted0;\n    }\n  }\n\n  return simulation;\n}\n", "import { voronoiMapSimulation as d3VoronoiMapSimulation } from 'd3-voronoi-map';\n\nexport function voronoiTreemap() {\n  //begin: constants\n  var DEFAULT_CONVERGENCE_RATIO = 0.01;\n  var DEFAULT_MAX_ITERATION_COUNT = 50;\n  var DEFAULT_MIN_WEIGHT_RATIO = 0.01;\n  var DEFAULT_PRNG = Math.random;\n  //end: constants\n\n  /////// Inputs ///////\n  var clip = [\n    [0, 0],\n    [0, 1],\n    [1, 1],\n    [1, 0],\n  ]; // clipping polygon\n  var extent = [\n    [0, 0],\n    [1, 1],\n  ]; // extent of the clipping polygon\n  var size = [1, 1]; // [width, height] of the clipping polygon\n  var convergenceRatio = DEFAULT_CONVERGENCE_RATIO; // targeted allowed error ratio; default 0.01 stops computation when cell areas error <= 1% clipping polygon's area\n  var maxIterationCount = DEFAULT_MAX_ITERATION_COUNT; // maximum allowed iteration; stops computation even if convergence is not reached; use a large amount for a sole converge-based computation stop\n  var minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO; // used to compute the minimum allowed weight; default 0.01 means 1% of max weight; handle near-zero weights, and leaves enought space for cell hovering\n  var prng = DEFAULT_PRNG; // pseudorandom number generator\n\n  //begin: internals\n  var unrelevantButNeedeData = [\n    {\n      weight: 1,\n    },\n    {\n      weight: 1,\n    },\n  ];\n  var _convenientReusableVoronoiMapSimulation = d3VoronoiMapSimulation(unrelevantButNeedeData).stop();\n  //end: internals\n\n  ///////////////////////\n  ///////// API /////////\n  ///////////////////////\n\n  function _voronoiTreemap(rootNode) {\n    recurse(clip, rootNode);\n  }\n\n  _voronoiTreemap.convergenceRatio = function (_) {\n    if (!arguments.length) {\n      return convergenceRatio;\n    }\n\n    convergenceRatio = _;\n    return _voronoiTreemap;\n  };\n\n  _voronoiTreemap.maxIterationCount = function (_) {\n    if (!arguments.length) {\n      return maxIterationCount;\n    }\n\n    maxIterationCount = _;\n    return _voronoiTreemap;\n  };\n\n  _voronoiTreemap.minWeightRatio = function (_) {\n    if (!arguments.length) {\n      return minWeightRatio;\n    }\n\n    minWeightRatio = _;\n    return _voronoiTreemap;\n  };\n\n  _voronoiTreemap.clip = function (_) {\n    if (!arguments.length) {\n      return clip;\n    }\n\n    //begin: use voronoiMap.clip() to handle clip/extent/size computation and borderline input (non-counterclockwise, non-convex, ...)\n    _convenientReusableVoronoiMapSimulation.clip(_);\n    //end: use voronoiMap.clip() to handle clip/extent/size computation\n    clip = _convenientReusableVoronoiMapSimulation.clip();\n    extent = _convenientReusableVoronoiMapSimulation.extent();\n    size = _convenientReusableVoronoiMapSimulation.size();\n    return _voronoiTreemap;\n  };\n\n  _voronoiTreemap.extent = function (_) {\n    if (!arguments.length) {\n      return extent;\n    }\n\n    //begin: use voronoiMap.extent() to handle clip/extent/size computation\n    _convenientReusableVoronoiMapSimulation.extent(_);\n    //end: use voronoiMap.clip() to handle clip/extent/size computation\n    clip = _convenientReusableVoronoiMapSimulation.clip();\n    extent = _convenientReusableVoronoiMapSimulation.extent();\n    size = _convenientReusableVoronoiMapSimulation.size();\n    return _voronoiTreemap;\n  };\n\n  _voronoiTreemap.size = function (_) {\n    if (!arguments.length) {\n      return size;\n    }\n\n    //begin: use voronoiMap.size() to handle clip/extent/size computation\n    _convenientReusableVoronoiMapSimulation.size(_);\n    //end: use voronoiMap.clip() to handle clip/extent/size computation\n    clip = _convenientReusableVoronoiMapSimulation.clip();\n    extent = _convenientReusableVoronoiMapSimulation.extent();\n    size = _convenientReusableVoronoiMapSimulation.size();\n    return _voronoiTreemap;\n  };\n\n  _voronoiTreemap.prng = function (_) {\n    if (!arguments.length) {\n      return prng;\n    }\n\n    prng = _;\n    return _voronoiTreemap;\n  };\n\n  ///////////////////////\n  /////// Private ///////\n  ///////////////////////\n\n  function recurse(clippingPolygon, node) {\n    var simulation;\n\n    //assign polygon to node\n    node.polygon = clippingPolygon;\n\n    if (node.height != 0) {\n      //compute one-level Voronoi map of children\n      simulation = d3VoronoiMapSimulation(node.children)\n        .clip(clippingPolygon)\n        .weight(function (d) {\n          return d.value;\n        })\n        .convergenceRatio(convergenceRatio)\n        .maxIterationCount(maxIterationCount)\n        .minWeightRatio(minWeightRatio)\n        .prng(prng)\n        .stop();\n\n      var state = simulation.state(); // retrieve the Voronoï map simulation's state\n\n      //begin: manually launch each iteration until the Voronoï map simulation ends\n      while (!state.ended) {\n        simulation.tick();\n        state = simulation.state();\n      }\n      //end: manually launch each iteration until the Voronoï map simulation ends\n\n      //begin: recurse on children\n      state.polygons.forEach(function (cp) {\n        recurse(cp, cp.site.originalObject.data.originalData);\n      });\n      //end: recurse on children\n    }\n  }\n\n  return _voronoiTreemap;\n}\n"],
  "mappings": "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",
  "names": ["now", "min", "max", "index", "array", "cross_default", "indexes", "cross_default", "hull_default", "length_default", "index", "intersection", "length_default", "direction", "hull_default", "boundingSites", "voronoiMapSimulation", "voronoiMapSimulation", "epsilon", "weightedVoronoi", "data", "simulation", "max", "initialPosition", "polygons", "flickeringMitigation"]
}
