// node_modules/d3-voronoi-map/node_modules/d3-polygon/src/area.js
function area_default(polygon) {
  var i = -1, n = polygon.length, a, b = polygon[n - 1], area = 0;
  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }
  return area / 2;
}

// node_modules/d3-voronoi-map/node_modules/d3-polygon/src/centroid.js
function centroid_default(polygon) {
  var i = -1, n = polygon.length, x = 0, y = 0, a, b = polygon[n - 1], c, k = 0;
  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }
  return k *= 3, [x / k, y / k];
}

// node_modules/d3-voronoi-map/node_modules/d3-polygon/src/contains.js
function contains_default(polygon, point) {
  var n = polygon.length, p = polygon[n - 1], x = point[0], y = point[1], x0 = p[0], y0 = p[1], x1, y1, inside = false;
  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;
    x0 = x1, y0 = y1;
  }
  return inside;
}

// node_modules/d3-voronoi-map/node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-voronoi-map/node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare = f;
  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }
  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x) => ascending_default(f(d), x);
}

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/number.js
function number_default(x) {
  return x === null ? NaN : +x;
}

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/extent.js
function extent_default(values, valueof) {
  let min2;
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min2 === void 0) {
          if (value >= value) min2 = max2 = value;
        } else {
          if (min2 > value) min2 = value;
          if (max2 < value) max2 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null) {
        if (min2 === void 0) {
          if (value >= value) min2 = max2 = value;
        } else {
          if (min2 > value) min2 = value;
          if (max2 < value) max2 = value;
        }
      }
    }
  }
  return [min2, max2];
}

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// node_modules/d3-weighted-voronoi/node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array2, i0 = 0, i1 = array2.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array2[m + i0];
      array2[m + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-weighted-voronoi/node_modules/d3-polygon/src/cross.js
function cross_default2(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}

// node_modules/d3-weighted-voronoi/node_modules/d3-polygon/src/hull.js
function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}
function computeUpperHullIndexes(points) {
  const n = points.length, indexes2 = [0, 1];
  let size = 2, i;
  for (i = 2; i < n; ++i) {
    while (size > 1 && cross_default2(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0) --size;
    indexes2[size++] = i;
  }
  return indexes2.slice(0, size);
}
function hull_default2(points) {
  if ((n = points.length) < 3) return null;
  var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull = [];
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
  return hull;
}

// node_modules/d3-weighted-voronoi/node_modules/d3-polygon/src/length.js
function length_default2(polygon) {
  var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.hypot(xa, ya);
  }
  return perimeter;
}

// node_modules/d3-weighted-voronoi/src/utils.js
var epsilon = 1e-10;
function epsilonesque(n) {
  return n <= epsilon && n >= -epsilon;
}
function dot(v0, v1) {
  return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;
}
function linearDependent(v0, v1) {
  return epsilonesque(v0.x * v1.y - v0.y * v1.x) && epsilonesque(v0.y * v1.z - v0.z * v1.y) && epsilonesque(v0.z * v1.x - v0.x * v1.z);
}
function polygonDirection(polygon) {
  var sign, crossproduct, p0, p1, p2, v0, v1, i;
  p0 = polygon[polygon.length - 2];
  p1 = polygon[polygon.length - 1];
  p2 = polygon[0];
  v0 = vect(p0, p1);
  v1 = vect(p1, p2);
  crossproduct = calculateCrossproduct(v0, v1);
  sign = Math.sign(crossproduct);
  p0 = p1;
  p1 = p2;
  p2 = polygon[1];
  v0 = v1;
  v1 = vect(p1, p2);
  crossproduct = calculateCrossproduct(v0, v1);
  if (Math.sign(crossproduct) !== sign) {
    return void 0;
  }
  for (i = 2; i < polygon.length - 1; i++) {
    p0 = p1;
    p1 = p2;
    p2 = polygon[i];
    v0 = v1;
    v1 = vect(p1, p2);
    crossproduct = calculateCrossproduct(v0, v1);
    if (Math.sign(crossproduct) !== sign) {
      return void 0;
    }
  }
  return sign;
}
function vect(from, to) {
  return [to[0] - from[0], to[1] - from[1]];
}
function calculateCrossproduct(v0, v1) {
  return v0[0] * v1[1] - v0[1] * v1[0];
}

// node_modules/d3-weighted-voronoi/src/conflictList.js
function ConflictListNode(face, vert) {
  this.face = face;
  this.vert = vert;
  this.nextf = null;
  this.prevf = null;
  this.nextv = null;
  this.prevv = null;
}
function ConflictList(forFace) {
  this.forFace = forFace;
  this.head = null;
}
ConflictList.prototype.add = function(cln) {
  if (this.head === null) {
    this.head = cln;
  } else {
    if (this.forFace) {
      this.head.prevv = cln;
      cln.nextv = this.head;
      this.head = cln;
    } else {
      this.head.prevf = cln;
      cln.nextf = this.head;
      this.head = cln;
    }
  }
};
ConflictList.prototype.isEmpty = function() {
  return this.head === null;
};
ConflictList.prototype.fill = function(visible) {
  if (this.forFace) {
    return;
  }
  var curr = this.head;
  do {
    visible.push(curr.face);
    curr.face.marked = true;
    curr = curr.nextf;
  } while (curr !== null);
};
ConflictList.prototype.removeAll = function() {
  if (this.forFace) {
    var curr = this.head;
    do {
      if (curr.prevf === null) {
        if (curr.nextf === null) {
          curr.vert.conflicts.head = null;
        } else {
          curr.nextf.prevf = null;
          curr.vert.conflicts.head = curr.nextf;
        }
      } else {
        if (curr.nextf != null) {
          curr.nextf.prevf = curr.prevf;
        }
        curr.prevf.nextf = curr.nextf;
      }
      curr = curr.nextv;
      if (curr != null) {
        curr.prevv = null;
      }
    } while (curr != null);
  } else {
    var curr = this.head;
    do {
      if (curr.prevv == null) {
        if (curr.nextv == null) {
          curr.face.conflicts.head = null;
        } else {
          curr.nextv.prevv = null;
          curr.face.conflicts.head = curr.nextv;
        }
      } else {
        if (curr.nextv != null) {
          curr.nextv.prevv = curr.prevv;
        }
        curr.prevv.nextv = curr.nextv;
      }
      curr = curr.nextf;
      if (curr != null)
        curr.prevf = null;
    } while (curr != null);
  }
};
ConflictList.prototype.getVertices = function() {
  var list = [], curr = this.head;
  while (curr !== null) {
    list.push(curr.vert);
    curr = curr.nextv;
  }
  return list;
};

// node_modules/d3-weighted-voronoi/src/vertex.js
function Vertex(x, y, z, weight, orig, isDummy) {
  this.x = x;
  this.y = y;
  this.weight = epsilon;
  this.index = 0;
  this.conflicts = new ConflictList(false);
  this.neighbours = null;
  this.nonClippedPolygon = null;
  this.polygon = null;
  this.originalObject = null;
  this.isDummy = false;
  if (orig !== void 0) {
    this.originalObject = orig;
  }
  if (isDummy != void 0) {
    this.isDummy = isDummy;
  }
  if (weight != null) {
    this.weight = weight;
  }
  if (z != null) {
    this.z = z;
  } else {
    this.z = this.projectZ(this.x, this.y, this.weight);
  }
}
Vertex.prototype.projectZ = function(x, y, weight) {
  return x * x + y * y - weight;
};
Vertex.prototype.setWeight = function(weight) {
  this.weight = weight;
  this.z = this.projectZ(this.x, this.y, this.weight);
};
Vertex.prototype.subtract = function(v) {
  return new Vertex(v.x - this.x, v.y - this.y, v.z - this.z);
};
Vertex.prototype.crossproduct = function(v) {
  return new Vertex(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
};
Vertex.prototype.equals = function(v) {
  return this.x === v.x && this.y === v.y && this.z === v.z;
};

// node_modules/d3-weighted-voronoi/src/plane3D.js
function Plane3D(face) {
  var p1 = face.verts[0];
  var p2 = face.verts[1];
  var p3 = face.verts[2];
  this.a = p1.y * (p2.z - p3.z) + p2.y * (p3.z - p1.z) + p3.y * (p1.z - p2.z);
  this.b = p1.z * (p2.x - p3.x) + p2.z * (p3.x - p1.x) + p3.z * (p1.x - p2.x);
  this.c = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);
  this.d = -1 * (p1.x * (p2.y * p3.z - p3.y * p2.z) + p2.x * (p3.y * p1.z - p1.y * p3.z) + p3.x * (p1.y * p2.z - p2.y * p1.z));
}
Plane3D.prototype.getNormZPlane = function() {
  return [
    -1 * (this.a / this.c),
    -1 * (this.b / this.c),
    -1 * (this.d / this.c)
  ];
};
Plane3D.prototype.getDualPointMappedToPlane = function() {
  var nplane = this.getNormZPlane();
  var dualPoint = new Point2D(nplane[0] / 2, nplane[1] / 2);
  return dualPoint;
};
function Point2D(x, y) {
  this.x = x;
  this.y = y;
}

// node_modules/d3-weighted-voronoi/src/vector.js
function Vector(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z;
}
Vector.prototype.negate = function() {
  this.x *= -1;
  this.y *= -1;
  this.z *= -1;
};
Vector.prototype.normalize = function() {
  var lenght = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  if (lenght > 0) {
    this.x /= lenght;
    this.y /= lenght;
    this.z /= lenght;
  }
};

// node_modules/d3-weighted-voronoi/src/hEdge.js
function HEdge(orig, dest, face) {
  this.next = null;
  this.prev = null;
  this.twin = null;
  this.orig = orig;
  this.dest = dest;
  this.iFace = face;
}
HEdge.prototype.isHorizon = function() {
  return this.twin !== null && !this.iFace.marked && this.twin.iFace.marked;
};
HEdge.prototype.findHorizon = function(horizon) {
  if (this.isHorizon()) {
    if (horizon.length > 0 && this === horizon[0]) {
      return;
    } else {
      horizon.push(this);
      this.next.findHorizon(horizon);
    }
  } else {
    if (this.twin !== null) {
      this.twin.next.findHorizon(horizon);
    }
  }
};
HEdge.prototype.isEqual = function(origin, dest) {
  return this.orig.equals(origin) && this.dest.equals(dest) || this.orig.equals(dest) && this.dest.equals(origin);
};

// node_modules/d3-weighted-voronoi/src/d3-weighted-voronoi-error.js
function d3WeightedVoronoiError(message) {
  this.message = message;
  this.stack = new Error().stack;
}
d3WeightedVoronoiError.prototype.name = "d3WeightedVoronoiError";
d3WeightedVoronoiError.prototype = new Error();

// node_modules/d3-weighted-voronoi/src/face.js
function Face(a, b, c, orient) {
  this.conflicts = new ConflictList(true);
  this.verts = [a, b, c];
  this.marked = false;
  var t = a.subtract(b).crossproduct(b.subtract(c));
  this.normal = new Vector(-t.x, -t.y, -t.z);
  this.normal.normalize();
  this.createEdges();
  this.dualPoint = null;
  if (orient != void 0) {
    this.orient(orient);
  }
}
Face.prototype.getDualPoint = function() {
  if (this.dualPoint == null) {
    var plane3d = new Plane3D(this);
    this.dualPoint = plane3d.getDualPointMappedToPlane();
  }
  return this.dualPoint;
};
Face.prototype.isVisibleFromBelow = function() {
  return this.normal.z < -14259414393190911e-25;
};
Face.prototype.createEdges = function() {
  this.edges = [];
  this.edges[0] = new HEdge(this.verts[0], this.verts[1], this);
  this.edges[1] = new HEdge(this.verts[1], this.verts[2], this);
  this.edges[2] = new HEdge(this.verts[2], this.verts[0], this);
  this.edges[0].next = this.edges[1];
  this.edges[0].prev = this.edges[2];
  this.edges[1].next = this.edges[2];
  this.edges[1].prev = this.edges[0];
  this.edges[2].next = this.edges[0];
  this.edges[2].prev = this.edges[1];
};
Face.prototype.orient = function(orient) {
  if (!(dot(this.normal, orient) < dot(this.normal, this.verts[0]))) {
    var temp = this.verts[1];
    this.verts[1] = this.verts[2];
    this.verts[2] = temp;
    this.normal.negate();
    this.createEdges();
  }
};
Face.prototype.getEdge = function(v0, v1) {
  for (var i = 0; i < 3; i++) {
    if (this.edges[i].isEqual(v0, v1)) {
      return this.edges[i];
    }
  }
  return null;
};
Face.prototype.link = function(face, v0, v1) {
  if (face instanceof Face) {
    var twin = face.getEdge(v0, v1);
    if (twin === null) {
      throw new d3WeightedVoronoiError("when linking, twin is null");
    }
    var edge = this.getEdge(v0, v1);
    if (edge === null) {
      throw new d3WeightedVoronoiError("when linking, twin is null");
    }
    twin.twin = edge;
    edge.twin = twin;
  } else {
    var twin = face;
    var edge = this.getEdge(twin.orig, twin.dest);
    twin.twin = edge;
    edge.twin = twin;
  }
};
Face.prototype.conflict = function(v) {
  return dot(this.normal, v) > dot(this.normal, this.verts[0]) + epsilon;
};
Face.prototype.getHorizon = function() {
  for (var i = 0; i < 3; i++) {
    if (this.edges[i].twin !== null && this.edges[i].twin.isHorizon()) {
      return this.edges[i];
    }
  }
  return null;
};
Face.prototype.removeConflict = function() {
  this.conflicts.removeAll();
};

// node_modules/d3-weighted-voronoi/src/convexHull.js
function ConvexHull() {
  this.points = [];
  this.facets = [];
  this.created = [];
  this.horizon = [];
  this.visible = [];
  this.current = 0;
}
ConvexHull.prototype.init = function(boundingSites, sites) {
  this.points = [];
  for (var i = 0; i < sites.length; i++) {
    this.points[i] = new Vertex(sites[i].x, sites[i].y, sites[i].z, null, sites[i], false);
  }
  this.points = this.points.concat(boundingSites);
};
ConvexHull.prototype.permutate = function() {
  var pointSize = this.points.length;
  for (var i = pointSize - 1; i > 0; i--) {
    var ra = Math.floor(Math.random() * i);
    var temp = this.points[ra];
    temp.index = i;
    var currentItem = this.points[i];
    currentItem.index = ra;
    this.points.splice(ra, 1, currentItem);
    this.points.splice(i, 1, temp);
  }
};
ConvexHull.prototype.prep = function() {
  if (this.points.length <= 3) {
    throw new d3WeightedVoronoiError("Less than 4 points");
  }
  for (var i = 0; i < this.points.length; i++) {
    this.points[i].index = i;
  }
  var v0, v1, v2, v3;
  var f1, f2, f3, f0;
  v0 = this.points[0];
  v1 = this.points[1];
  v2 = v3 = null;
  for (var i = 2; i < this.points.length; i++) {
    if (!(linearDependent(v0, this.points[i]) && linearDependent(v1, this.points[i]))) {
      v2 = this.points[i];
      v2.index = 2;
      this.points[2].index = i;
      this.points.splice(i, 1, this.points[2]);
      this.points.splice(2, 1, v2);
      break;
    }
  }
  if (v2 === null) {
    throw new d3WeightedVoronoiError("Not enough non-planar Points (v2 is null)");
  }
  f0 = new Face(v0, v1, v2);
  for (var i = 3; i < this.points.length; i++) {
    if (!epsilonesque(dot(f0.normal, f0.verts[0]) - dot(f0.normal, this.points[i]))) {
      v3 = this.points[i];
      v3.index = 3;
      this.points[3].index = i;
      this.points.splice(i, 1, this.points[3]);
      this.points.splice(3, 1, v3);
      break;
    }
  }
  if (v3 === null) {
    throw new d3WeightedVoronoiError("Not enough non-planar Points (v3 is null)");
  }
  f0.orient(v3);
  f1 = new Face(v0, v2, v3, v1);
  f2 = new Face(v0, v1, v3, v2);
  f3 = new Face(v1, v2, v3, v0);
  this.addFacet(f0);
  this.addFacet(f1);
  this.addFacet(f2);
  this.addFacet(f3);
  f0.link(f1, v0, v2);
  f0.link(f2, v0, v1);
  f0.link(f3, v1, v2);
  f1.link(f2, v0, v3);
  f1.link(f3, v2, v3);
  f2.link(f3, v3, v1);
  this.current = 4;
  var v;
  for (var i = this.current; i < this.points.length; i++) {
    v = this.points[i];
    if (f0.conflict(v)) {
      this.addConflict(f0, v);
    }
    if (f1.conflict(v)) {
      this.addConflict(f1, v);
    }
    if (f2.conflict(v)) {
      this.addConflict(f2, v);
    }
    if (f3.conflict(v)) {
      this.addConflict(f3, v);
    }
  }
}, // IN: Faces old1 old2 and fn
ConvexHull.prototype.addConflicts = function(old1, old2, fn) {
  var l1 = old1.conflicts.getVertices();
  var l2 = old2.conflicts.getVertices();
  var nCL = [];
  var v1, v2;
  var i, l;
  i = l = 0;
  while (i < l1.length || l < l2.length) {
    if (i < l1.length && l < l2.length) {
      v1 = l1[i];
      v2 = l2[l];
      if (v1.index === v2.index) {
        nCL.push(v1);
        i++;
        l++;
      } else if (v1.index > v2.index) {
        nCL.push(v1);
        i++;
      } else {
        nCL.push(v2);
        l++;
      }
    } else if (i < l1.length) {
      nCL.push(l1[i++]);
    } else {
      nCL.push(l2[l++]);
    }
  }
  for (var i = nCL.length - 1; i >= 0; i--) {
    v1 = nCL[i];
    if (fn.conflict(v1)) this.addConflict(fn, v1);
  }
};
ConvexHull.prototype.addConflict = function(face, vert) {
  var e = new ConflictListNode(face, vert);
  face.conflicts.add(e);
  vert.conflicts.add(e);
};
ConvexHull.prototype.removeConflict = function(f) {
  f.removeConflict();
  var index2 = f.index;
  f.index = -1;
  if (index2 === this.facets.length - 1) {
    this.facets.splice(this.facets.length - 1, 1);
    return;
  }
  if (index2 >= this.facets.length || index2 < 0) return;
  var last = this.facets.splice(this.facets.length - 1, 1);
  last[0].index = index2;
  this.facets.splice(index2, 1, last[0]);
};
ConvexHull.prototype.addFacet = function(face) {
  face.index = this.facets.length;
  this.facets.push(face);
};
ConvexHull.prototype.compute = function() {
  this.prep();
  while (this.current < this.points.length) {
    var next = this.points[this.current];
    if (next.conflicts.isEmpty()) {
      this.current++;
      continue;
    }
    this.created = [];
    this.horizon = [];
    this.visible = [];
    next.conflicts.fill(this.visible);
    var e;
    for (var jF = 0; jF < this.visible.length; jF++) {
      e = this.visible[jF].getHorizon();
      if (e !== null) {
        e.findHorizon(this.horizon);
        break;
      }
    }
    var last = null, first = null;
    for (var hEi = 0; hEi < this.horizon.length; hEi++) {
      var hE = this.horizon[hEi];
      var fn = new Face(next, hE.orig, hE.dest, hE.twin.next.dest);
      fn.conflicts = new ConflictList(true);
      this.addFacet(fn);
      this.created.push(fn);
      this.addConflicts(hE.iFace, hE.twin.iFace, fn);
      fn.link(hE);
      if (last !== null) fn.link(last, next, hE.orig);
      last = fn;
      if (first === null) first = fn;
    }
    if (first !== null && last !== null) {
      last.link(first, next, this.horizon[0].orig);
    }
    if (this.created.length != 0) {
      for (var f = 0; f < this.visible.length; f++) {
        this.removeConflict(this.visible[f]);
      }
      this.current++;
      this.created = [];
    }
  }
  return this.facets;
};
ConvexHull.prototype.clear = function() {
  this.points = [];
  this.facets = [];
  this.created = [];
  this.horizon = [];
  this.visible = [];
  this.current = 0;
};

// node_modules/d3-weighted-voronoi/src/d3-polygon-clip.js
function polygonClip(clip, subject) {
  var input, closed = polygonClosed(subject), i = -1, n = clip.length - polygonClosed(clip), j, m, a = clip[n - 1], b, c, d, intersection2;
  while (++i < n) {
    input = subject.slice();
    subject.length = 0;
    b = clip[i];
    c = input[(m = input.length - closed) - 1];
    j = -1;
    while (++j < m) {
      d = input[j];
      if (polygonInside(d, a, b)) {
        if (!polygonInside(c, a, b)) {
          intersection2 = polygonIntersect(c, d, a, b);
          if (isFinite(intersection2[0])) {
            subject.push(intersection2);
          }
        }
        subject.push(d);
      } else if (polygonInside(c, a, b)) {
        intersection2 = polygonIntersect(c, d, a, b);
        if (isFinite(intersection2[0])) {
          subject.push(intersection2);
        }
      }
      c = d;
    }
    if (closed) subject.push(subject[0]);
    a = b;
  }
  return subject;
}
function polygonInside(p, a, b) {
  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
}
function polygonIntersect(c, d, a, b) {
  var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
  return [x1 + ua * x21, y1 + ua * y21];
}
function polygonClosed(coordinates) {
  var a = coordinates[0], b = coordinates[coordinates.length - 1];
  return !(a[0] - b[0] || a[1] - b[1]);
}

// node_modules/d3-weighted-voronoi/src/powerDiagram.js
function getFacesOfDestVertex(edge) {
  var faces = [];
  var previous = edge;
  var first = edge.dest;
  var site = first.originalObject;
  var neighbours = [];
  do {
    previous = previous.twin.prev;
    var siteOrigin = previous.orig.originalObject;
    if (!siteOrigin.isDummy) {
      neighbours.push(siteOrigin);
    }
    var iFace = previous.iFace;
    if (iFace.isVisibleFromBelow()) {
      faces.push(iFace);
    }
  } while (previous !== edge);
  site.neighbours = neighbours;
  return faces;
}
function computePowerDiagramIntegrated(sites, boundingSites, clippingPolygon) {
  var convexHull = new ConvexHull();
  convexHull.clear();
  convexHull.init(boundingSites, sites);
  var facets = convexHull.compute(sites);
  var polygons = [];
  var verticesVisited = [];
  var facetCount = facets.length;
  for (var i = 0; i < facetCount; i++) {
    var facet = facets[i];
    if (facet.isVisibleFromBelow()) {
      for (var e = 0; e < 3; e++) {
        var edge = facet.edges[e];
        var destVertex = edge.dest;
        var site = destVertex.originalObject;
        if (!verticesVisited[destVertex.index]) {
          verticesVisited[destVertex.index] = true;
          if (site.isDummy) {
            continue;
          }
          var faces = getFacesOfDestVertex(edge);
          var protopoly = [];
          var lastX = null;
          var lastY = null;
          var dx = 1;
          var dy = 1;
          for (var j = 0; j < faces.length; j++) {
            var point = faces[j].getDualPoint();
            var x1 = point.x;
            var y1 = point.y;
            if (lastX !== null) {
              dx = lastX - x1;
              dy = lastY - y1;
              if (dx < 0) {
                dx = -dx;
              }
              if (dy < 0) {
                dy = -dy;
              }
            }
            if (dx > epsilon || dy > epsilon) {
              protopoly.push([x1, y1]);
              lastX = x1;
              lastY = y1;
            }
          }
          site.nonClippedPolygon = protopoly.reverse();
          if (!site.isDummy && length_default2(site.nonClippedPolygon) > 0) {
            var clippedPoly = polygonClip(clippingPolygon, site.nonClippedPolygon);
            site.polygon = clippedPoly;
            clippedPoly.site = site;
            if (clippedPoly.length > 0) {
              polygons.push(clippedPoly);
            }
          }
        }
      }
    }
  }
  return polygons;
}

// node_modules/d3-weighted-voronoi/src/d3-weighted-voronoi.js
function weightedVoronoi() {
  var x = function(d) {
    return d.x;
  };
  var y = function(d) {
    return d.y;
  };
  var weight = function(d) {
    return d.weight;
  };
  var clip = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0]
  ];
  var extent = [
    [0, 0],
    [1, 1]
  ];
  var size = [1, 1];
  function _weightedVoronoi(data) {
    var formatedSites;
    formatedSites = data.map(function(d) {
      return new Vertex(x(d), y(d), null, weight(d), d, false);
    });
    return computePowerDiagramIntegrated(formatedSites, boundingSites(), clip);
  }
  _weightedVoronoi.x = function(_) {
    if (!arguments.length) {
      return x;
    }
    x = _;
    return _weightedVoronoi;
  };
  _weightedVoronoi.y = function(_) {
    if (!arguments.length) {
      return y;
    }
    y = _;
    return _weightedVoronoi;
  };
  _weightedVoronoi.weight = function(_) {
    if (!arguments.length) {
      return weight;
    }
    weight = _;
    return _weightedVoronoi;
  };
  _weightedVoronoi.clip = function(_) {
    var direction2, xExtent, yExtent;
    if (!arguments.length) {
      return clip;
    }
    xExtent = extent_default(
      _.map(function(c) {
        return c[0];
      })
    );
    yExtent = extent_default(
      _.map(function(c) {
        return c[1];
      })
    );
    direction2 = polygonDirection(_);
    if (direction2 === void 0) {
      clip = hull_default2(_);
    } else if (direction2 === 1) {
      clip = _.reverse();
    } else {
      clip = _;
    }
    extent = [
      [xExtent[0], yExtent[0]],
      [xExtent[1], yExtent[1]]
    ];
    size = [xExtent[1] - xExtent[0], yExtent[1] - yExtent[0]];
    return _weightedVoronoi;
  };
  _weightedVoronoi.extent = function(_) {
    if (!arguments.length) {
      return extent;
    }
    clip = [_[0], [_[0][0], _[1][1]], _[1], [_[1][0], _[0][1]]];
    extent = _;
    size = [_[1][0] - _[0][0], _[1][1] - _[0][1]];
    return _weightedVoronoi;
  };
  _weightedVoronoi.size = function(_) {
    if (!arguments.length) {
      return size;
    }
    clip = [
      [0, 0],
      [0, _[1]],
      [_[0], _[1]],
      [_[0], 0]
    ];
    extent = [[0, 0], _];
    size = _;
    return _weightedVoronoi;
  };
  function boundingSites() {
    var minX, maxX, minY, maxY, width, height, x0, x1, y0, y1, boundingData = [], boundingSites2 = [];
    minX = extent[0][0];
    maxX = extent[1][0];
    minY = extent[0][1];
    maxY = extent[1][1];
    width = maxX - minX;
    height = maxY - minY;
    x0 = minX - width;
    x1 = maxX + width;
    y0 = minY - height;
    y1 = maxY + height;
    boundingData[0] = [x0, y0];
    boundingData[1] = [x0, y1];
    boundingData[2] = [x1, y1];
    boundingData[3] = [x1, y0];
    for (var i = 0; i < 4; i++) {
      boundingSites2.push(
        new Vertex(
          boundingData[i][0],
          boundingData[i][1],
          null,
          epsilon,
          new Vertex(boundingData[i][0], boundingData[i][1], null, epsilon, null, true),
          true
        )
      );
    }
    return boundingSites2;
  }
  return _weightedVoronoi;
}

// node_modules/d3-voronoi-map/src/flickering-mitigation.js
function FlickeringMitigation() {
  this.growthChangesLength = DEFAULT_LENGTH;
  this.totalAvailableArea = NaN;
  this.lastAreaError = NaN;
  this.lastGrowth = NaN;
  this.growthChanges = [];
  this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
  this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
}
var DEFAULT_LENGTH = 10;
function direction(h0, h1) {
  return h0 >= h1 ? 1 : -1;
}
function generateGrowthChangeWeights(length) {
  var initialWeight = 3;
  var weightDecrement = 1;
  var minWeight = 1;
  var weightedCount = initialWeight;
  var growthChangeWeights = [];
  for (var i = 0; i < length; i++) {
    growthChangeWeights.push(weightedCount);
    weightedCount -= weightDecrement;
    if (weightedCount < minWeight) {
      weightedCount = minWeight;
    }
  }
  return growthChangeWeights;
}
function computeGrowthChangeWeightsSum(growthChangeWeights) {
  var growthChangeWeightsSum = 0;
  for (var i = 0; i < growthChangeWeights.length; i++) {
    growthChangeWeightsSum += growthChangeWeights[i];
  }
  return growthChangeWeightsSum;
}
FlickeringMitigation.prototype.reset = function() {
  this.lastAreaError = NaN;
  this.lastGrowth = NaN;
  this.growthChanges = [];
  this.growthChangesLength = DEFAULT_LENGTH;
  this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
  this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
  this.totalAvailableArea = NaN;
  return this;
};
FlickeringMitigation.prototype.clear = function() {
  this.lastAreaError = NaN;
  this.lastGrowth = NaN;
  this.growthChanges = [];
  return this;
};
FlickeringMitigation.prototype.length = function(_) {
  if (!arguments.length) {
    return this.growthChangesLength;
  }
  if (parseInt(_) > 0) {
    this.growthChangesLength = Math.floor(parseInt(_));
    this.growthChangeWeights = generateGrowthChangeWeights(this.growthChangesLength);
    this.growthChangeWeightsSum = computeGrowthChangeWeightsSum(this.growthChangeWeights);
  } else {
    console.warn("FlickeringMitigation.length() accepts only positive integers; unable to handle " + _);
  }
  return this;
};
FlickeringMitigation.prototype.totalArea = function(_) {
  if (!arguments.length) {
    return this.totalAvailableArea;
  }
  if (parseFloat(_) > 0) {
    this.totalAvailableArea = parseFloat(_);
  } else {
    console.warn("FlickeringMitigation.totalArea() accepts only positive numbers; unable to handle " + _);
  }
  return this;
};
FlickeringMitigation.prototype.add = function(areaError) {
  var secondToLastAreaError, secondToLastGrowth;
  secondToLastAreaError = this.lastAreaError;
  this.lastAreaError = areaError;
  if (!isNaN(secondToLastAreaError)) {
    secondToLastGrowth = this.lastGrowth;
    this.lastGrowth = direction(this.lastAreaError, secondToLastAreaError);
  }
  if (!isNaN(secondToLastGrowth)) {
    this.growthChanges.unshift(this.lastGrowth != secondToLastGrowth);
  }
  if (this.growthChanges.length > this.growthChangesLength) {
    this.growthChanges.pop();
  }
  return this;
};
FlickeringMitigation.prototype.ratio = function() {
  var weightedChangeCount = 0;
  var ratio;
  if (this.growthChanges.length < this.growthChangesLength) {
    return 0;
  }
  if (this.lastAreaError > this.totalAvailableArea / 10) {
    return 0;
  }
  for (var i = 0; i < this.growthChangesLength; i++) {
    if (this.growthChanges[i]) {
      weightedChangeCount += this.growthChangeWeights[i];
    }
  }
  ratio = weightedChangeCount / this.growthChangeWeightsSum;
  return ratio;
};

// node_modules/d3-voronoi-map/src/initial-position-policies/random.js
function random_default() {
  var clippingPolygon, extent, minX, maxX, minY, maxY, dx, dy;
  function _random(d, i, arr, voronoiMapSimulation2) {
    var shouldUpdateInternals = false;
    var x, y;
    if (clippingPolygon !== voronoiMapSimulation2.clip()) {
      clippingPolygon = voronoiMapSimulation2.clip();
      extent = voronoiMapSimulation2.extent();
      shouldUpdateInternals = true;
    }
    if (shouldUpdateInternals) {
      updateInternals();
    }
    x = minX + dx * voronoiMapSimulation2.prng()();
    y = minY + dy * voronoiMapSimulation2.prng()();
    while (!contains_default(clippingPolygon, [x, y])) {
      x = minX + dx * voronoiMapSimulation2.prng()();
      y = minY + dy * voronoiMapSimulation2.prng()();
    }
    return [x, y];
  }
  ;
  function updateInternals() {
    minX = extent[0][0];
    maxX = extent[1][0];
    minY = extent[0][1];
    maxY = extent[1][1];
    dx = maxX - minX;
    dy = maxY - minY;
  }
  ;
  return _random;
}

// node_modules/d3-voronoi-map/src/initial-weight-policies/half-average-area.js
function half_average_area_default() {
  var clippingPolygon, dataArray, siteCount, totalArea, halfAverageArea;
  function _halfAverageArea(d, i, arr, voronoiMapSimulation2) {
    var shouldUpdateInternals = false;
    if (clippingPolygon !== voronoiMapSimulation2.clip()) {
      clippingPolygon = voronoiMapSimulation2.clip();
      shouldUpdateInternals |= true;
    }
    if (dataArray !== arr) {
      dataArray = arr;
      shouldUpdateInternals |= true;
    }
    if (shouldUpdateInternals) {
      updateInternals();
    }
    return halfAverageArea;
  }
  ;
  function updateInternals() {
    siteCount = dataArray.length;
    totalArea = area_default(clippingPolygon);
    halfAverageArea = totalArea / siteCount / 2;
  }
  return _halfAverageArea;
}

// node_modules/d3-voronoi-map/src/d3-voronoi-map-error.js
function d3VoronoiMapError(message) {
  this.message = message;
  this.stack = new Error().stack;
}
d3VoronoiMapError.prototype.name = "d3VoronoiMapError";
d3VoronoiMapError.prototype = new Error();

// node_modules/d3-voronoi-map/src/d3-voronoi-map.js
function voronoiMapSimulation(data) {
  var DEFAULT_CONVERGENCE_RATIO = 0.01;
  var DEFAULT_MAX_ITERATION_COUNT = 50;
  var DEFAULT_MIN_WEIGHT_RATIO = 0.01;
  var DEFAULT_PRNG = Math.random;
  var DEFAULT_INITIAL_POSITION = random_default();
  var DEFAULT_INITIAL_WEIGHT = half_average_area_default();
  var RANDOM_INITIAL_POSITION = random_default();
  var epsilon2 = 1e-10;
  var weight = function(d) {
    return d.weight;
  };
  var convergenceRatio = DEFAULT_CONVERGENCE_RATIO;
  var maxIterationCount = DEFAULT_MAX_ITERATION_COUNT;
  var minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO;
  var prng = DEFAULT_PRNG;
  var initialPosition = DEFAULT_INITIAL_POSITION;
  var initialWeight = DEFAULT_INITIAL_WEIGHT;
  var weightedVoronoi2 = weightedVoronoi(), flickeringMitigation = new FlickeringMitigation(), shouldInitialize = true, siteCount, totalArea, areaErrorTreshold, iterationCount, polygons, areaError, converged, ended;
  var simulation, stepper = timer(step), event = dispatch_default("tick", "end");
  const HANDLE_OVERWEIGHTED_VARIANT = 1;
  const HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT = 1e3;
  var handleOverweighted;
  function sqr(d) {
    return Math.pow(d, 2);
  }
  function squaredDistance(s0, s1) {
    return sqr(s1.x - s0.x) + sqr(s1.y - s0.y);
  }
  simulation = {
    tick,
    restart: function() {
      stepper.restart(step);
      return simulation;
    },
    stop: function() {
      stepper.stop();
      return simulation;
    },
    weight: function(_) {
      if (!arguments.length) {
        return weight;
      }
      weight = _;
      shouldInitialize = true;
      return simulation;
    },
    convergenceRatio: function(_) {
      if (!arguments.length) {
        return convergenceRatio;
      }
      convergenceRatio = _;
      shouldInitialize = true;
      return simulation;
    },
    maxIterationCount: function(_) {
      if (!arguments.length) {
        return maxIterationCount;
      }
      maxIterationCount = _;
      return simulation;
    },
    minWeightRatio: function(_) {
      if (!arguments.length) {
        return minWeightRatio;
      }
      minWeightRatio = _;
      shouldInitialize = true;
      return simulation;
    },
    clip: function(_) {
      if (!arguments.length) {
        return weightedVoronoi2.clip();
      }
      weightedVoronoi2.clip(_);
      shouldInitialize = true;
      return simulation;
    },
    extent: function(_) {
      if (!arguments.length) {
        return weightedVoronoi2.extent();
      }
      weightedVoronoi2.extent(_);
      shouldInitialize = true;
      return simulation;
    },
    size: function(_) {
      if (!arguments.length) {
        return weightedVoronoi2.size();
      }
      weightedVoronoi2.size(_);
      shouldInitialize = true;
      return simulation;
    },
    prng: function(_) {
      if (!arguments.length) {
        return prng;
      }
      prng = _;
      shouldInitialize = true;
      return simulation;
    },
    initialPosition: function(_) {
      if (!arguments.length) {
        return initialPosition;
      }
      initialPosition = _;
      shouldInitialize = true;
      return simulation;
    },
    initialWeight: function(_) {
      if (!arguments.length) {
        return initialWeight;
      }
      initialWeight = _;
      shouldInitialize = true;
      return simulation;
    },
    state: function() {
      if (shouldInitialize) {
        initializeSimulation();
      }
      return {
        ended,
        iterationCount,
        convergenceRatio: areaError / totalArea,
        polygons
      };
    },
    on: function(name, _) {
      if (arguments.length === 1) {
        return event.on(name);
      }
      event.on(name, _);
      return simulation;
    }
  };
  function step() {
    tick();
    event.call("tick", simulation);
    if (ended) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick() {
    if (!ended) {
      if (shouldInitialize) {
        initializeSimulation();
      }
      polygons = adapt(polygons, flickeringMitigation.ratio());
      iterationCount++;
      areaError = computeAreaError(polygons);
      flickeringMitigation.add(areaError);
      converged = areaError < areaErrorTreshold;
      ended = converged || iterationCount >= maxIterationCount;
    }
  }
  function initializeSimulation() {
    setHandleOverweighted();
    siteCount = data.length;
    totalArea = Math.abs(area_default(weightedVoronoi2.clip()));
    areaErrorTreshold = convergenceRatio * totalArea;
    flickeringMitigation.clear().totalArea(totalArea);
    iterationCount = 0;
    converged = false;
    polygons = initialize(data, simulation);
    ended = false;
    shouldInitialize = false;
  }
  function initialize(data2, simulation2) {
    var maxWeight = data2.reduce(function(max2, d) {
      return Math.max(max2, weight(d));
    }, -Infinity), minAllowedWeight = maxWeight * minWeightRatio;
    var weights, mapPoints;
    weights = data2.map(function(d, i, arr) {
      return {
        index: i,
        weight: Math.max(weight(d), minAllowedWeight),
        initialPosition: initialPosition(d, i, arr, simulation2),
        initialWeight: initialWeight(d, i, arr, simulation2),
        originalData: d
      };
    });
    mapPoints = createMapPoints(weights, simulation2);
    handleOverweighted(mapPoints);
    return weightedVoronoi2(mapPoints);
  }
  function createMapPoints(basePoints, simulation2) {
    var totalWeight = basePoints.reduce(function(acc, bp) {
      return acc += bp.weight;
    }, 0);
    var initialPosition2;
    return basePoints.map(function(bp, i, bps) {
      initialPosition2 = bp.initialPosition;
      if (!contains_default(weightedVoronoi2.clip(), initialPosition2)) {
        initialPosition2 = DEFAULT_INITIAL_POSITION(bp, i, bps, simulation2);
      }
      return {
        index: bp.index,
        targetedArea: totalArea * bp.weight / totalWeight,
        data: bp,
        x: initialPosition2[0],
        y: initialPosition2[1],
        weight: bp.initialWeight
        // ArlindNocaj/Voronoi-Treemap-Library uses an epsilonesque initial weight; using heavier initial weights allows faster weight adjustements, hence faster stabilization
      };
    });
  }
  function adapt(polygons2, flickeringMitigationRatio) {
    var adaptedMapPoints;
    adaptPositions(polygons2, flickeringMitigationRatio);
    adaptedMapPoints = polygons2.map(function(p) {
      return p.site.originalObject;
    });
    polygons2 = weightedVoronoi2(adaptedMapPoints);
    if (polygons2.length < siteCount) {
      throw new d3VoronoiMapError("at least 1 site has no area, which is not supposed to arise");
    }
    adaptWeights(polygons2, flickeringMitigationRatio);
    adaptedMapPoints = polygons2.map(function(p) {
      return p.site.originalObject;
    });
    polygons2 = weightedVoronoi2(adaptedMapPoints);
    if (polygons2.length < siteCount) {
      throw new d3VoronoiMapError("at least 1 site has no area, which is not supposed to arise");
    }
    return polygons2;
  }
  function adaptPositions(polygons2, flickeringMitigationRatio) {
    var newMapPoints = [], flickeringInfluence = 0.5;
    var flickeringMitigation2, d, polygon, mapPoint, centroid, dx, dy;
    flickeringMitigation2 = flickeringInfluence * flickeringMitigationRatio;
    d = 1 - flickeringMitigation2;
    for (var i = 0; i < siteCount; i++) {
      polygon = polygons2[i];
      mapPoint = polygon.site.originalObject;
      centroid = centroid_default(polygon);
      dx = centroid[0] - mapPoint.x;
      dy = centroid[1] - mapPoint.y;
      dx *= d;
      dy *= d;
      mapPoint.x += dx;
      mapPoint.y += dy;
      newMapPoints.push(mapPoint);
    }
    handleOverweighted(newMapPoints);
  }
  function adaptWeights(polygons2, flickeringMitigationRatio) {
    var newMapPoints = [], flickeringInfluence = 0.1;
    var flickeringMitigation2, polygon, mapPoint, currentArea, adaptRatio, adaptedWeight;
    flickeringMitigation2 = flickeringInfluence * flickeringMitigationRatio;
    for (var i = 0; i < siteCount; i++) {
      polygon = polygons2[i];
      mapPoint = polygon.site.originalObject;
      currentArea = area_default(polygon);
      adaptRatio = mapPoint.targetedArea / currentArea;
      adaptRatio = Math.max(adaptRatio, 1 - flickeringInfluence + flickeringMitigation2);
      adaptRatio = Math.min(adaptRatio, 1 + flickeringInfluence - flickeringMitigation2);
      adaptedWeight = mapPoint.weight * adaptRatio;
      adaptedWeight = Math.max(adaptedWeight, epsilon2);
      mapPoint.weight = adaptedWeight;
      newMapPoints.push(mapPoint);
    }
    handleOverweighted(newMapPoints);
  }
  function handleOverweighted0(mapPoints) {
    var fixCount = 0;
    var fixApplied, tpi, tpj, weightest, lightest, sqrD, adaptedWeight;
    do {
      if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {
        throw new d3VoronoiMapError("handleOverweighted0 is looping too much");
      }
      fixApplied = false;
      for (var i = 0; i < siteCount; i++) {
        tpi = mapPoints[i];
        for (var j = i + 1; j < siteCount; j++) {
          tpj = mapPoints[j];
          if (tpi.weight > tpj.weight) {
            weightest = tpi;
            lightest = tpj;
          } else {
            weightest = tpj;
            lightest = tpi;
          }
          sqrD = squaredDistance(tpi, tpj);
          if (sqrD < weightest.weight - lightest.weight) {
            adaptedWeight = sqrD + lightest.weight / 2;
            adaptedWeight = Math.max(adaptedWeight, epsilon2);
            weightest.weight = adaptedWeight;
            fixApplied = true;
            fixCount++;
            break;
          }
        }
        if (fixApplied) {
          break;
        }
      }
    } while (fixApplied);
  }
  function handleOverweighted1(mapPoints) {
    var fixCount = 0;
    var fixApplied, tpi, tpj, weightest, lightest, sqrD, overweight;
    do {
      if (fixCount > HANLDE_OVERWEIGHTED_MAX_ITERATION_COUNT) {
        throw new d3VoronoiMapError("handleOverweighted1 is looping too much");
      }
      fixApplied = false;
      for (var i = 0; i < siteCount; i++) {
        tpi = mapPoints[i];
        for (var j = i + 1; j < siteCount; j++) {
          tpj = mapPoints[j];
          if (tpi.weight > tpj.weight) {
            weightest = tpi;
            lightest = tpj;
          } else {
            weightest = tpj;
            lightest = tpi;
          }
          sqrD = squaredDistance(tpi, tpj);
          if (sqrD < weightest.weight - lightest.weight) {
            overweight = weightest.weight - lightest.weight - sqrD;
            lightest.weight += overweight + epsilon2;
            fixApplied = true;
            fixCount++;
            break;
          }
        }
        if (fixApplied) {
          break;
        }
      }
    } while (fixApplied);
  }
  function computeAreaError(polygons2) {
    var areaErrorSum = 0;
    var polygon, mapPoint, currentArea;
    for (var i = 0; i < siteCount; i++) {
      polygon = polygons2[i];
      mapPoint = polygon.site.originalObject;
      currentArea = area_default(polygon);
      areaErrorSum += Math.abs(mapPoint.targetedArea - currentArea);
    }
    return areaErrorSum;
  }
  function setHandleOverweighted() {
    switch (HANDLE_OVERWEIGHTED_VARIANT) {
      case 0:
        handleOverweighted = handleOverweighted0;
        break;
      case 1:
        handleOverweighted = handleOverweighted1;
        break;
      default:
        console.error("unknown 'handleOverweighted' variant; using variant #1");
        handleOverweighted = handleOverweighted0;
    }
  }
  return simulation;
}

// node_modules/d3-voronoi-treemap/src/d3-voronoi-treemap.js
function voronoiTreemap() {
  var DEFAULT_CONVERGENCE_RATIO = 0.01;
  var DEFAULT_MAX_ITERATION_COUNT = 50;
  var DEFAULT_MIN_WEIGHT_RATIO = 0.01;
  var DEFAULT_PRNG = Math.random;
  var clip = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0]
  ];
  var extent = [
    [0, 0],
    [1, 1]
  ];
  var size = [1, 1];
  var convergenceRatio = DEFAULT_CONVERGENCE_RATIO;
  var maxIterationCount = DEFAULT_MAX_ITERATION_COUNT;
  var minWeightRatio = DEFAULT_MIN_WEIGHT_RATIO;
  var prng = DEFAULT_PRNG;
  var unrelevantButNeedeData = [
    {
      weight: 1
    },
    {
      weight: 1
    }
  ];
  var _convenientReusableVoronoiMapSimulation = voronoiMapSimulation(unrelevantButNeedeData).stop();
  function _voronoiTreemap(rootNode) {
    recurse(clip, rootNode);
  }
  _voronoiTreemap.convergenceRatio = function(_) {
    if (!arguments.length) {
      return convergenceRatio;
    }
    convergenceRatio = _;
    return _voronoiTreemap;
  };
  _voronoiTreemap.maxIterationCount = function(_) {
    if (!arguments.length) {
      return maxIterationCount;
    }
    maxIterationCount = _;
    return _voronoiTreemap;
  };
  _voronoiTreemap.minWeightRatio = function(_) {
    if (!arguments.length) {
      return minWeightRatio;
    }
    minWeightRatio = _;
    return _voronoiTreemap;
  };
  _voronoiTreemap.clip = function(_) {
    if (!arguments.length) {
      return clip;
    }
    _convenientReusableVoronoiMapSimulation.clip(_);
    clip = _convenientReusableVoronoiMapSimulation.clip();
    extent = _convenientReusableVoronoiMapSimulation.extent();
    size = _convenientReusableVoronoiMapSimulation.size();
    return _voronoiTreemap;
  };
  _voronoiTreemap.extent = function(_) {
    if (!arguments.length) {
      return extent;
    }
    _convenientReusableVoronoiMapSimulation.extent(_);
    clip = _convenientReusableVoronoiMapSimulation.clip();
    extent = _convenientReusableVoronoiMapSimulation.extent();
    size = _convenientReusableVoronoiMapSimulation.size();
    return _voronoiTreemap;
  };
  _voronoiTreemap.size = function(_) {
    if (!arguments.length) {
      return size;
    }
    _convenientReusableVoronoiMapSimulation.size(_);
    clip = _convenientReusableVoronoiMapSimulation.clip();
    extent = _convenientReusableVoronoiMapSimulation.extent();
    size = _convenientReusableVoronoiMapSimulation.size();
    return _voronoiTreemap;
  };
  _voronoiTreemap.prng = function(_) {
    if (!arguments.length) {
      return prng;
    }
    prng = _;
    return _voronoiTreemap;
  };
  function recurse(clippingPolygon, node) {
    var simulation;
    node.polygon = clippingPolygon;
    if (node.height != 0) {
      simulation = voronoiMapSimulation(node.children).clip(clippingPolygon).weight(function(d) {
        return d.value;
      }).convergenceRatio(convergenceRatio).maxIterationCount(maxIterationCount).minWeightRatio(minWeightRatio).prng(prng).stop();
      var state = simulation.state();
      while (!state.ended) {
        simulation.tick();
        state = simulation.state();
      }
      state.polygons.forEach(function(cp) {
        recurse(cp, cp.site.originalObject.data.originalData);
      });
    }
  }
  return _voronoiTreemap;
}
export {
  voronoiTreemap
};
//# sourceMappingURL=d3-voronoi-treemap.js.map
